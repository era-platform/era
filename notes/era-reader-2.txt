\- TODO: Implement all of this. Maybe some parts can be adopted
\- gradually by the current reader implementation in era-reader.js,
\- but some of the overall architecture might be simpler if made from
\- scratch.
\-
\- This is a drastic redesign of the Era reader. Notably, it allows
\- the comments in an escape sequence to use the same syntax as
\- comments in a string or an s-expression, and it simplifies some
\- escape sequence syntaxes by having them use the s-expression reader
\- to obtain their structure, such as \(ch 1234) and
\- \;(wq my-quasiquotation-level). It has a pair of whitespace
\- normalization toggles ;yp and ;np rather than just one, and these
\- affect only designated regions of the string. It adds a let syntax
\- ;(lq ...) for quasiquotation labels. It uses the escape sequence \^
\- for \ so that ^ can be parsed as an identifier, rather than
\- dedicating an extra syntax to that purpose. It uses \= for
\- comments and \; for most escapes. It does interpolations simply by
\- using \;uq_ where _ is the interpolated s-expression. To facilitate
\- all this s-expression parsing, the syntax allows identifiers and
\- s-expression escapes to be explicitly initiated and terminated with
\- , rather than relying on whitespace or punctuation.
\-
\- Last but not least, this reader documentation uses EBNF format, and
\- it may be written in a slightly less roundabout way. For instance,
\- the original documentation was first organized before it was known
\- there'd need to be a "naive" parsing mode for s-expressions that
\- were in *suppressed* escape seequences; apparently building
\- s-expressions by string concatenation is a special design concern
\- all its own. The "naive" mode is actually more low-level in the
\- reader than the full s-expression mode is, so here we document it
\- first.


\- This is the design of a reader for Era's own dialect of
\- s-expressions.
\-
\- After reading, the s-expression format is simple:
\-
\-   - An s-expression is either a list or an interpolated string.
\-   - A list is either empty or an s-expression followed by a list.
\-   - An interpolated string is an uninterpolated string, optionally
\-     followed by an s-expression and an interpolated string.
\-   - An uninterpolated string is a sequence of Unicode scalars
\-     (integers 0x0..0x10FFFF but excluding UTF-16 surrogates
\-     0xD800..0xDFFF).
\-
\- Before reading, the most complicated system is the string syntax.
\- The design considerations for the string syntax actually impact
\- most of the other parts of the syntax design.
\-
\- In the design of the overall syntax, we have several use cases in
\- mind:
\-
\-   - Story: As someone who talks to people about code, I want to use
\-     code snippets as diagrams in natural-language discussions.
\-
\-     - Problem: Some authorship systems would require me to take
\-       screenshots or do export/import in order to properly copy and
\-       paste between authored snippets and discussion.
\-
\-     - Solution: Like many programming langage syntaxes, Era's
\-       syntax is edited as plain Unicode text. These days, plain
\-       Unicode text is a widely used medium for natural language
\-       communication.
\-
\-   - Story: As a programmer, I encounter nested structures all the
\-     time, ranging from lambda calculus terms to loop bodies to data
\-     structures. It would be nice if editing these trees were
\-     straightforward.
\-
\-     - Problem: Most languages' code is plain-text-based, and plain
\-       text is flat.
\-
\-     - Solution: This syntax follows in the tradition of the Lisp
\-       family of languages by defining a single (a b c ...) nested
\-       list syntax that can be used for various kinds of nesting.
\-       Once a programmer adopts tools or habits for this syntax,
\-       it's almost like the syntax is a tree rather than a list in
\-       the first place.
\-
\-     - Problem: Actually, some of the nesting I'm dealing with is
\-       very lopsided to the right, like monadic/continuation-passing
\-       style, pointful function composition, or right-associative
\-       algebraic operations.
\-
\-     - Solution: There's a (a b /c d) syntax, and it's shorthand for
\-       (a b (c d)). Besides saving a ) here and there, since / and (
\-       look so different, they don't have to follow the same
\-       indentation convention. Continuation-passing style code can
\-       be written one call per line, making it look like imperative
\-       code. Pointful function composition can be written
\-       (f/g/h ...).
\-
\-   - Story: As a programmer who uses a text-based programming
\-     language, namely this one, I have the skills and tools to edit
\-     plain text, and I'd like to take advantage of them.
\-
\-     - Problem: If I want to specify plain text assets for my
\-       program to use, I don't want to switch to another editor
\-       environment just to define those assets.
\-
\-     - Solution: Like lots of programming language syntaxes, Era's
\-       syntax supports string literals \;qq[...]. A string literal
\-       can contain *practically* any text, and that text will be
\-       *mostly* reflected in the reader's final result.
\-
\-   - Story: As a programmer who uses a text-based programming
\-     language, namely this one, I'd like to generate text-based code
\-     sometimes. In fact, I'd like to generate code to generate code,
\-     and so on.
\-
\-     - Problem: Most string syntaxes frustrate me because they
\-       require me to write escape sequences in my code. Different
\-       stages of generated code look completely different because I
\-       have to write escape sequences for my escape sequences. Since
\-       they look so different, I can't easily refactor my project in
\-       ways that add or remove stages.
\-
\-     - Solution: This string syntax uses an escape sequences
\-       \;qq[...] that looks exactly like the string syntax itself,
\-       and the sole purpose of this escape sequence is for
\-       generating code that contains this string syntax. Escape
\-       sequences occurring inside these brackets are suppressed, so
\-       \n generates "\n" rather than a newline, and so on. Thanks to
\-       this, every stage of generated code looks almost entirely the
\-       same.
\-
\-     - Problem: The escape sequence \;qq[...] generates both "\;qq["
\-       and "]" in a single string, and sometimes I want to insert a
\-       value in the middle. I could write this as a concatenation
\-       bookended by one string that escapes \;qq[ as \^;qq\<, and
\-       one that escapes ] as \>, but I'd rather not make such a
\-       pervasive syntax replacement for such a focused insertion.
\-
\-     - Solution: There's an interpolation escape sequence \;uq...
\-       which lets s-expressions be interspersed with other string
\-       parts at read time. This way both \;qq[ and ] can be part of
\-       the same string literal, even if there's an interpolation in
\-       the middle.
\-
\-     - Problem: Wouldn't that be suppressed like any other escape
\-       sequence inside the \;qq[...] boundaries?
\-
\-     - Solution: All escape sequences can actually be un-suppressed
\-       any number of levels by writing things like
\-       \;uq;uq;uq;uq... for example. The escape sequence \;uq... is
\-       actually \... modified by \;uq and \;qq[...] is \[...]
\-       modified by \;qq. The function of \;qq and \;uq is to
\-       suppress and un-suppress escape sequences respectively.
\-
\-     - Problem: Different stages of code still look different
\-       because some of them use \;uq... while others have to use
\-       \;uq;uq;uq;uq... in its place. If I refactor my code to add
\-       or remove a stage before or after all other stages, I'm fine,
\-       but if I refactor it to add or remove a stage somewhere in
\-       the middle, I have to go all over my code to add or remove
\-       ";uq".
\-
\-     - Solution: You can use \;(wq foo);qq... to locally define the
\-       name "foo" to refer to the current quasiquotation level
\-       before you start a new one. Then you can use \;(rq foo)... to
\-       rewind back to the original level. Altogether, you can write
\-       \;(wq foo);qq[...\;(rq foo)(...)...] instead of
\-       \;qq[...\;uq(...)...] for example.
\-
\-     - Problem: I'm generating a \;uq... interpolation sequence, and
\-       I want to build the inserted s-expression by string
\-       concatenation. However, that means it won't really be an
\-       s-expression; it will have string interpolations interspersed
\-       in its code. This means I can't necessarily count on the
\-       reader to know where a suppressed \;uq... begins and ends.
\-
\-     - Solution: That's definitely an issue if some of the strings
\-       you're inserting have unmatched delimiters. Other cases
\-       should be fine, because the syntax first parses the
\-       s-expression using a "naive" mode where any sequence of
\-       characters and escape sequences is permitted as long as the
\-       list delimiters match up. Some s-expressions are not
\-       delimited, because they're standalone identifiers or escape
\-       sequences. In "naive" mode, these can be any intermixed
\-       sequence of identifier characters and escape sequences, and
\-       the sequence will stop at the first non-identifier character
\-       encountered.
\-
\-   - As a programmer whose programs contain error messages and
\-     documentation, I'd like to write long strings of
\-     natural-language prose.
\-
\-     - Problem: In most programming languages, if I want to be picky
\-       about whitespace in a long string, then I have to make sure
\-       not to insert any whitespace that I don't want the string to
\-       contain. This gets in my way when I want to use indentation
\-       and line breaks that match the surrounding code style.
\-
\-     - Solution: The \;qq[...] string syntax collapses all
\-       whitespace. It also supports whitespace escapes for local
\-       cases when that behavior is unwanted, such as blank lines
\-       between natural-language paragraphs.
\-
\-     - Problem: Sometimes I do want to be picky about whitespace,
\-       such as when I'm writing my natural-language prose in some
\-       kind of markdown format.
\-
\-     - Solution: The \;yp[...] escape sequence lets you write a span
\-       of preformatted text, where whitespace is not collapsed. You
\-       can write \;qq[\;yp/...] if you want this setting to apply to
\-       the whole string, and you can write \;np[...] around any span
\-       of text that should not be considered preformatted.
\-
\- The design we've settled on at this point is the following:

<other safe> ::= ("`" | "=" | ";" | "'" | "." | "/")
<other> ::= (<other safe> | "\" | "(" | ")" | "[" | "]")
<other comma> ::= (<other> | ",")
<tx> ::= ...any printable character except <other comma>
<nl> ::= ...any line break character or CRLF
<ws> ::= ...any whitespace character except <nl>
<end> ::= ...the end of the document
<wsnl> ::= (<ws> | <nl>)
<string element> ::= (<tx> | <other safe>)*
  \- Ambiguity resolution: Doesn't matter. (Actually, the entire
  \- reader syntax should have no ambiguity that makes a difference,
  \- unless there's a bug. That's what all the lookaheads are here to
  \- ensure.)

<string element> ::= <wsnl>*
  \- Ambiguity resolution: Doesn't matter.
  \-
  \- If preformatting is off, this is a span of raw whitespace
  \- surrounded by lurking commands to normalize it along with all
  \- preceding and following raw whitespace. Otherwise, it's just a
  \- span of raw whitespace. Normalizing whitespace means turning one
  \- or more raw whitespace characters into a single space.

<string element> ::= "[" <string element>* "]"
<string element> ::= "(" <string element>* ")"
  \- This represents the contents surrounded by brackets.
  \-
  \- NOTE: This gives us delimiters we can use without any need to
  \- escape the same delimiters when they're used inside. This is
  \- useful for expression languages. We reserve two delimiters for
  \- use this way: The delimiter ( ) is very common for expression
  \- languages, and it's sometimes easier to type thanks to its use in
  \- English. The delimiter [ ] is unshifted on an American keyboard,
  \- and it's more visually distinct from ( ) than { } is. By not
  \- reserving the delimiter { } in the same way, we leave open the
  \- possibility of syntaxes where some delimiters don't need to be
  \- balanced, with one example being our own \{ and \} escape
  \- sequences.

<string element> ::= <string escape>

<string escape> ::= "\" <escape>
  \- What this represents varies by the escape sequence.
  \-
  \- When processing an escape sequence, occurrences of whitespace and
  \- comments are ignored, delimiters are normalized, and occurrences
  \- of reader depth modifiers are collected. Occurrences of \;__
  \- unflatten their first s-expressions, but these s-expressions may
  \- still be treated as string data as well.
  \-
  \- At any quasiquotation depth greater than the depths listed here,
  \- the escape sequences are suppressed, treated as uninterpreted
  \- string data.
  \-
  \- Occurrences of \_ at a depth of 0 or 1, where _ is an
  \- s-expression, unflatten their s-expressions.
  \-
  \- \^ \< \> \{ \} at a depth of 1 represent \ [ ] ( )
  \- \s \t \r \n at a depth of 1 represent space, tab, carriage
  \-   return, newline as non-raw whitespace, surrounded by lurking
  \-   commands to eliminate all preceding and following raw
  \-   whitespace.
  \- \c (meaning "concatenate") at a depth of 1 represents a lurking
  \-   command to eliminate all preceding and following raw
  \-   whitespace.
  \- \;yp(_) (meaning "yes preformatting") turns preformatting on in
  \-   its body for as long as the current quasiquotation depth lasts.
  \-   It represents its body's contents without the brackets,
  \-   unpeeked, surrounded with lurking commands that inhibit other
  \-   lurking commands from passing through.
  \- \;np(_) (meaning "no preformatting") turns preformatting off in
  \-   its body for as long as the current quasiquotation depth lasts.
  \-   It represents its body's contents without the brackets,
  \-   unpeeked, surrounded with lurking commands that inhibit other
  \-   lurking commands from passing through.
  \- \=_ \;rm_ at a depth of 1 represent empty strings. This is useful
  \-   for comments.
  \- \(ch _) at a depth of 1 represents the Unicode scalar value
  \-   obtained by parsing the given string as a hexadecimal number.
  \- \_ at a depth of 0, where _ is an s-expression, represents an
  \-   interpolation of the given s-expression into the string.

<rm> ::= <ws>

<rm> ::= "\" <escape>
  \- What this represents does not actually vary by the escape
  \- sequence, but the accepted escape sequences are listed below.
  \-
  \- When processing an escape sequence, occurrences of whitespace and
  \- comments are ignored, delimiters are normalized, and occurrences
  \- of reader depth modifiers are collected. Occurrences of \;__
  \- unflatten their first s-expressions, but these s-expressions may
  \- still be treated as string data as well.
  \-
  \- \=_ \;rm_ at a depth of 0 represent comments.

<rmnl> ::= (<rm> | <nl>)

<escape> ::= <rmnl>* <escape>
  \- Ambiguity resolution: Doesn't matter.
<escape> ::= ";" <escape> <escape>
  \- NOTE: The character ; suggests two-ness in its shape.
<escape> ::=
  lookahead("[" | "(" | "/" | "," | <tx>)
  <naive non-infix s-expression>
<escape> ::=
  "=" (<tx> | <ws> | <other comma>)* lookahead(<nl> | <end>)
\- NOTE: We don't have escape sequences \) or \] because any such
\- sequence would need to have both its characters escaped to be
\- represented as a string, since otherwise this syntax would
\- interpret the ) or ] in other ways.
\-
\- NOTE: We're specifically avoiding special-casing certain characters
\- in the syntax altogether:
\-
\-  ~ ! @ # $ % ^ & * _ + { } | : " < > ? are shifted on an American
\-    keyboard, so they're a last resort, and we've made them valid
\-    identifier characters. Identifier characters include Basic Latin
\-    letters and digits and the - character as well. Some identifiers
\-    are special-cased in escape sequences, in the spirit of reserved
\-    words.
\-
\-  ` ' just haven't been used yet. However, they're specifically
\-    invalid as identifier characters just in case.

<naive non-infix s-expression> ::= "[" <string element>* "]"
<naive non-infix s-expression> ::= "(" <string element>* ")"
<naive non-infix s-expression> ::=
  "/" <string element>* lookahead("]" | ")")
<naive non-infix s-expression> ::=
  ","? (<tx> | <string escape>)+
  ("," | lookahead(<wsnl> | <other> | <end>))

<s-expression> ::= <s-expression> <rmnl>* "." <non-infix s-expression>
  \- This represents a two-element list.
<s-expression> ::= <non-infix s-expression>
<non-infix s-expression> ::= <rmnl>* <non-infix s-expression>
  \- Ambiguity resolution: Doesn't matter.
<non-infix s-expression> ::= "[" <s-expression>* <rmnl>* "]"
<non-infix s-expression> ::= "(" <s-expression>* <rmnl>* ")"
<non-infix s-expression> ::=
  "/" <s-expression>* <rmnl>* lookahead("]" | ")")
<non-infix s-expression> ::=
  ","? <tx>+ ("," | lookahead(<wsnl> | <other> | <end>))
  \- This represents a string s-expression. It can only express
  \- certain strings.

<non-infix s-expression> ::=
  ","? "\" <escape> ("," | lookahead(<wsnl> | <other> | <end>))
  \- What this represents varies by the escape sequence.
  \-
  \- When processing an escape sequence, occurrences of whitespace and
  \- comments are ignored, delimiters are normalized, and occurrences
  \- of reader depth modifiers are collected. Occurrences of \;__
  \- unflatten their first s-expressions, but these s-expressions may
  \- still be treated as string data as well.
  \-
  \- \_ at a depth of 0, where _ is an s-expression, unflattens its
  \-   s-expression, and it represents its s-expression value. This is
  \-   useful because it means the code (... \;qq/\/a b ...) generates
  \-   an s-expression equivalent to that generated by
  \-   (... \;qq/(a b ...)), but without requiring an extra ending
  \-   bracket.
  \-   \-
  \-   \- NOTE: It wouldn't be the same to write (... \;qq//a b ...)
  \-   \- because / intentionally has no special meaning in a string.
  \-   \- Existing textual syntaxes tend to use / for things like
  \-   \- division, comments, and markup end tags, and if we had a
  \-   \- special meaning for / it would be more cumbersome to
  \-   \- generate these syntaxes.
  \-
  \- \(_) at a depth of 1 represents an interpolated string
  \-   s-expression. The contents are unpeeked. If preformatting is
  \-   off, the string is surrounded by lurking commands to eliminate
  \-   its leading and trailing whitespace. Whether preformatting is
  \-   on or not, the lurking commands in the string are processed.

<top-level s-expression> ::=
  <top-level s-expression> <rm>* "." <non-infix s-expression>
  \- This represents a two-element list.
<top-level s-expression> ::= <non-infix s-expression>

<top level> ::= <top-level s-expression>* <rmnl>*
  \- This unflattens each s-expression, and it represents the sequence
  \- of their s-expression values. This sequence can be parsed
  \- incrementally from first to last.


\- Reader depth modifiers:
\-
\- These modify escape sequences. For instance, \() can be modified as
\- by ;qq by writing \;qq().
\-
\- ;qq (meaning "quasiquote") increases the depth by 1.
\- ;uq (meaning "unquote") decreases the depth by 1.
\- ;(wq _) (meaning "with current quasiquotation level") lets the
\-   given string be bound to the current quasiquotation depth in the
\-   quasiquotation depth environment for as long as the current
\-   quasiquotation depth lasts.
\- ;(lq _ _) (meaning "let quasiquotation level") looks up the
\-   quasiquotation depth the second given string is bound to in the
\-   quasiquotation depth environment, and it lets the first given
\-   string be bound to that quasiquotation depth in the
\-   quasiquotation depth environment for as long as the current
\-   quasiquotation depth lasts.
\- ;(rq _) (meaning "restore quasiquotation level") looks up the
\-   quasiquotation depth the given string is bound to in the
\-   quasiquotation depth environment, and it decreases the
\-   quasiquotation depth to that.

\- NOTE: We give most escape sequences two-letter names because that
\- that's a little more mnemonic than the traditional one-letter
\- names. It also lets us use "l" and "o" without confusing them with
\- digits, lets us avoid resorting to idiosyncratic capitalization,
\- and gives us a four-letter string like "=,pr" we can grep for. For
\- escapes dedicated to single characters, we use short escape
\- sequences with punctuation like "\<" or letters like "\t" depending
\- on whether the original character was already punctuation. The
\- substitute punctuation helps it continue to stand out.

\- Whenever an s-expression is unflattened, for the initial state of
\- that unflattening, the quasiquotation depth is 0, the
\- quasiquotation depth environment is empty, and preformatting is
\- off. Until an s-expression is unflattened, it's just treated as
\- string data, and it can contain string escape sequences that
\- wouldn't be valid in an s-expression. This way, an s-expression can
\- be built up by string concatenation.

\- Whenever a delimited sequence of string elements is unpeeked, if
\- any suppressed escape sequence in the string uses a / delimiter
\- that ends at the same place the whole sequence ends, that
\- suppressed / delimiter is converted to a suppressed [ ] or ( )
\- delimiter corresponding to the whole sequence's closing delimiter.
