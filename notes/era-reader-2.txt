\- TODO: Implement all of this. Maybe some parts can be adopted
\- gradually by the current reader implementation in era-reader.js,
\- but some of the overall architecture might be simpler if made from
\- scratch.
\-
\- This is a drastic redesign of the Era reader. Notably, it allows
\- the comments in an escape sequence to use the same syntax as
\- comments in a string or an s-expression, and it simplifies some
\- escape sequence syntaxes by having them use the s-expression reader
\- to obtain their structure, such as \,(ch 1234) and
\- \=,(wq my-quasiquotation-level). It has a pair of whitespace
\- normalization toggles =,yp and =,np rather than just one, and these
\- affect only designated regions of the string. It adds a let syntax
\- =,(lq ...) for quasiquotation labels. It uses the syntax \.` to
\- escape \ rather than dedicating an extra syntax to that purpose. It
\- uses \- for comments, \=, for most escapes, and \, for
\- interpolations.
\-
\- Last but not least, this reader documentation uses EBNF format, and
\- it may be written in a slightly less roundabout way. For instance,
\- the original documentation was first organized before it was known
\- there'd need to be a "naive" parsing mode for s-expressions that
\- were in *suppressed* escape seequences; apparently building
\- s-expressions by string concatenation is a special design concern
\- all its own. The "naive" mode is actually more low-level in the
\- reader than the full s-expression mode is, so here we document it
\- first.


\- This is the design of a reader for Era's own dialect of
\- s-expressions.
\-
\- After reading, the s-expression format is simple:
\-
\-   - An s-expression is either a list or an interpolated string.
\-   - A list is either empty or an s-expression followed by a list.
\-   - An interpolated string is an uninterpolated string, optionally
\-     followed by an s-expression and an interpolated string.
\-   - An uninterpolated string is a sequence of Unicode scalars
\-     (integers 0x0..0x10FFFF but excluding UTF-16 surrogates
\-     0xD800..0xDFFF).
\-
\- Before reading, the most complicated system is the string syntax.
\- The design considerations for the string syntax actually impact
\- most of the other parts of the syntax design.
\-
\- In the design of the overall syntax, we have several use cases in
\- mind:
\-
\-   - Story: As someone who talks to people about code, I want to use
\-     code snippets as diagrams in natural-language discussions.
\-
\-     - Problem: Some authorship systems would require me to take
\-       screenshots or do export/import in order to properly copy and
\-       paste between authored snippets and discussion.
\-
\-     - Solution: Like many programming langage syntaxes, Era's
\-       syntax is edited as plain Unicode text. These days, plain
\-       Unicode text is a widely used medium for natural language
\-       communication.
\-
\-   - Story: As a programmer, I encounter nested structures all the
\-     time, ranging from lambda calculus terms to loop bodies to data
\-     structures. It would be nice if editing these trees were
\-     straightforward.
\-
\-     - Problem: Most languages' code is plain-text-based, and plain
\-       text is flat.
\-
\-     - Solution: This syntax follows in the tradition of the Lisp
\-       family of languages by defining a single (a b c ...) nested
\-       list syntax that can be used for various kinds of nesting.
\-       Once a programmer adopts tools or habits for this syntax,
\-       it's almost like the syntax is a tree rather than a list in
\-       the first place.
\-
\-     - Problem: Actually, some of the nesting I'm dealing with is
\-       very lopsided to the right, like monadic/continuation-passing
\-       style, pointful function composition, or right-associative
\-       algebraic operations.
\-
\-     - Solution: There's a (a b /c d) syntax, and it's shorthand for
\-       (a b (c d)). Besides saving a ) here and there, since / and (
\-       look so different, they don't have to follow the same
\-       indentation convention. Continuation-passing style code can
\-       be written one call per line, making it look like imperative
\-       code. Pointful function composition can be written
\-       (f/g/h ...).
\-
\-   - Story: As a programmer who uses a text-based programming
\-     language, namely this one, I have the skills and tools to edit
\-     plain text, and I'd like to take advantage of them.
\-
\-     - Problem: If I want to specify plain text assets for my
\-       program to use, I don't want to switch to another editor
\-       environment just to define those assets.
\-
\-     - Solution: Like lots of programming language syntaxes, Era's
\-       syntax supports string literals \=,qq[...]. A string literal
\-       can contain *practically* any text, and that text will be
\-       *mostly* reflected in the reader's final result.
\-
\-   - Story: As a programmer who uses a text-based programming
\-     language, namely this one, I'd like to generate text-based code
\-     sometimes. In fact, I'd like to generate code to generate code,
\-     and so on.
\-
\-     - Problem: Most string syntaxes frustrate me because they
\-       require me to write escape sequences in my code. Different
\-       stages of generated code look completely different because I
\-       have to write escape sequences for my escape sequences. Since
\-       they look so different, I can't easily refactor my project in
\-       ways that add or remove stages.
\-
\-     - Solution: This string syntax uses an escape sequences
\-       \=,qq[...] that looks exactly like the string syntax itself,
\-       and the sole purpose of this escape sequence is for
\-       generating code that contains this string syntax. Escape
\-       sequences occurring inside these brackets are suppressed, so
\-       \,n generates "\,n" rather than a newline, and so on. Thanks
\-       to this, every stage of generated code looks almost entirely
\-       the same.
\-
\-     - Problem: The escape sequence \=,qq[...] generates both
\-       "\=,qq[" and "]" in a single string, and sometimes I want to
\-       insert a value in the middle. I could write this as a
\-       concatenation bookended by one string that escapes \=,qq[ as
\-       \.`=,qq\.< and one that escapes ] as \.> but I'd rather not
\-       make such a pervasive syntax replacement for such a focused
\-       insertion.
\-
\-     - Solution: There's an interpolation escape sequence
\-       \=,uq,expression-goes-here which lets s-expressions be
\-       interspersed with other string parts at read time. This way
\-       both \=,qq[ and ] can be part of the same string literal,
\-       even if there's an interpolation in the middle.
\-
\-     - Problem: Wouldn't that be suppressed like any other escape
\-       sequence inside the \=,qq[...] boundaries?
\-
\-     - Solution: All escape sequences can actually be un-suppressed
\-       any number of levels by writing things like
\-       \=,uq=,uq=,uq=,uq,... for example. The escape sequence
\-       \=,uq,... is actually \, modified by \=,uq and \=,qq[...] is
\-       \[...] modified by \=,qq. The function of \=,qq and \=,uq is
\-       to suppress and un-suppress escape sequences respectively.
\-
\-     - Problem: Different stages of code still look different
\-       because some of them use \=,uq,... while others have to use
\-       \=,uq=,uq=,uq=,uq,... in its place. If I refactor my code to
\-       add or remove a stage before or after all other stages, I'm
\-       fine, but if I refactor it to add or remove a stage somewhere
\-       in the middle, I have to go all over my code to add or remove
\-       "=,uq".
\-
\-     - Solution: You can use \=,(wq foo)=,qq... to locally define
\-       the name "foo" to refer to the current quasiquotation level
\-       before you start a new one. Then you can use \=,(rq foo)...
\-       to rewind back to the original level. Altogether, you can
\-       write \=,(wq foo)=,qq[...\=,(rq foo),(...)...] instead of
\-       \=,qq[...\=,uq,(...)...] for example.
\-
\-     - Problem: I'm generating a \=,uq,... interpolation sequence,
\-       and I want to build the inserted s-expression by string
\-       concatenation. However, that means it won't really be an
\-       s-expression; it will have string interpolations interspersed
\-       in its code. This means I can't necessarily count on the
\-       reader to know where a suppressed \=,uq,... begins and ends.
\-
\-     - Solution: That's definitely an issue if some of the strings
\-       you're inserting have unmatched delimiters. Other cases
\-       should be fine, because the , syntax first parses the
\-       s-expression using a "naive" mode where any sequence of
\-       characters and escape sequences is permitted as long as the
\-       list delimiters match up. Some s-expressions are not
\-       delimited, because they're standalone identifiers or escape
\-       sequences. In "naive" mode, these can be any intermixed
\-       sequence of identifier characters and escape sequences, and
\-       the sequence will stop at the first non-identifier character
\-       encountered.
\-
\-   - As a programmer whose programs contain error messages and
\-     documentation, I'd like to write long strings of
\-     natural-language prose.
\-
\-     - Problem: In most programming languages, if I want to be picky
\-       about whitespace in a long string, then I have to make sure
\-       not to insert any whitespace that I don't want the string to
\-       contain. This gets in my way when I want to use indentation
\-       and line breaks that match the surrounding code style.
\-
\-     - Solution: The \=,qq[...] string syntax collapses all
\-       whitespace. It also supports whitespace escapes for local
\-       cases when that behavior is unwanted, such as blank lines
\-       between natural-language paragraphs.
\-
\-     - Problem: Sometimes I do want to be picky about whitespace,
\-       such as when I'm writing my natural-language prose in some
\-       kind of markdown format.
\-
\-     - Solution: The \=,yp[...] escape sequence lets you write a
\-       span of preformatted text, where whitespace is not collapsed.
\-       You can write \=,qq[\=,yp/...] if you want this setting to
\-       apply to the whole string, and you can write \=,np[...]
\-       around any span of text that should not be considered
\-       preformatted.
\-
\- The design we've settled on at this point is the following:

<other> ::= ("." | "\" | "/" | "(" | ")" | "[" | "]")
<tx> ::= ...any printable character except <other>
<nl> ::= ...any line break character or CRLF
<ws> ::= ...any whitespace character except <nl>
<end> ::= ...the end of the document
<wsnl> ::= (<ws> | <nl>)
<string element> ::= (<tx> | "." | "/")*
  \- Ambiguity resolution: Doesn't matter. (Actually, the entire
  \- reader syntax should have no ambiguity that makes a difference,
  \- unless there's a bug. That's what all the lookaheads are here to
  \- ensure.)

<string element> ::= <wsnl>*
  \- Ambiguity resolution: Doesn't matter.
  \-
  \- If preformatting is off, this is a span of raw whitespace
  \- surrounded by lurking commands to normalize it along with all
  \- preceding and following raw whitespace. Otherwise, it's just a
  \- span of raw whitespace. Normalizing whitespace means turning one
  \- or more raw whitespace characters into a single space.

<string element> ::= "[" <string element>* "]"
<string element> ::= "(" <string element>* ")"
  \- This represents the contents surrounded by brackets.
  \-
  \- NOTE: This gives us delimiters we can use without any need to
  \- escape the same delimiters when they're used inside. This is
  \- useful for expression languages. We reserve two delimiters for
  \- use this way: The delimiter ( ) is very common for expression
  \- languages, and it's sometimes easier to type thanks to its use in
  \- English. The delimiter [ ] is unshifted on an American keyboard,
  \- and it's more visually distinct from ( ) than { } is. By not
  \- reserving the delimiter { } in the same way, we leave open the
  \- possibility of syntaxes where some delimiters don't need to be
  \- balanced, with one example being our own \.{ and \.} escape
  \- sequences.

<string element> ::= <string escape>

<string escape> ::= "\" <escape>
  \- What this represents varies by the escape sequence.
  \-
  \- When processing an escape sequence, occurrences of whitespace and
  \- comments are ignored, delimiters are normalized, and occurrences
  \- of reader depth modifiers are collected. Occurrences of =,
  \- unflatten their s-expressions, but these s-expressions may still
  \- be treated as string data as well.
  \-
  \- At any quasiquotation depth greater than the depths listed here,
  \- the escape sequences are suppressed, treated as uninterpreted
  \- string data.
  \-
  \- Occurrences of \, at a depth of 0 or 1 unflatten their
  \- s-expressions.
  \-
  \- \.` \.< \.> \.{ \.} at a depth of 1 represent \ [ ] ( )
  \- \,s \,t \,r \,n at a depth of 1 represent space, tab, carriage
  \-   return, newline as non-raw whitespace, surrounded by lurking
  \-   commands to eliminate all preceding and following raw
  \-   whitespace.
  \- \,c (meaning "concatenate") at a depth of 1 represents a lurking
  \-   command to eliminate all preceding and following raw
  \-   whitespace.
  \- \=,yp(_) (meaning "yes preformatting") turns preformatting on in
  \-   its body for as long as the current quasiquotation depth lasts.
  \-   It represents its body's contents without the brackets,
  \-   unpeeked, surrounded with lurking commands that inhibit other
  \-   lurking commands from passing through.
  \- \=,np(_) (meaning "no preformatting") turns preformatting off in
  \-   its body for as long as the current quasiquotation depth lasts.
  \-   It represents its body's contents without the brackets,
  \-   unpeeked, surrounded with lurking commands that inhibit other
  \-   lurking commands from passing through.
  \- \-_ \=,rm_ at a depth of 1 represent empty strings. This is
  \-   useful for comments.
  \- \,(ch _) at a depth of 1 represents the Unicode scalar value
  \-   obtained by parsing the given string as a hexadecimal number.
  \- \,_ at a depth of 0 represents an interpolation of the given
  \-   s-expression into the string.

<rm> ::= <ws>

<rm> ::= "\" <escape>
  \- What this represents does not actually vary by the escape
  \- sequence, but the accepted escape sequences are listed below.
  \-
  \- When processing an escape sequence, occurrences of whitespace and
  \- comments are ignored, delimiters are normalized, and occurrences
  \- of reader depth modifiers are collected. Occurrences of =,
  \- unflatten their s-expressions, but these s-expressions may still
  \- be treated as string data as well.
  \-
  \- \-_ \=,rm_ at a depth of 0 represent comments.

<rmnl> ::= (<rm> | <nl>)

<escape> ::= <rmnl>* <escape>
  \- Ambiguity resolution: Doesn't matter.

<escape> ::= "=" <escape> <escape>
  \- NOTE: The character = not only suggests two-ness in its shape but
  \- also calls up the imagery of a (let x = 2 ...) syntax, which is
  \- occasionally similar to the way we're actually using it. Although
  \- : has the same qualifications, = is unshifted.

<escape> ::= "," <wsnl>* <naive non-infix s-expression>
  \- NOTE: Comment escapes are not allowed between a , and its
  \- s-expression. That's because arbitrary string escapes are allowed
  \- in the s-expression, even at the start of the s-expression, and
  \- some of these string escapes can be confused with comment
  \- escapes.
<escape> ::= "." <tx>
<escape> ::= "-" (<tx> | <ws> | <other>)* lookahead(<nl> | <end>)
<escape> ::= "[" <string element>* "]"
<escape> ::= "(" <string element>* ")"
<escape> ::= "/" <string element>* lookahead("]" | ")")
\- NOTE: We're specifically avoiding certain characters in escape
\- sequences:
\-
\-  ) ] would be particularly inconvenient characters no matter what
\-    purpose they were put to. Any \) or \] escape sequence would
\-    need to have both its characters escaped to be represented as a
\-    string, since otherwise this syntax would interpret the ) or ]
\-    in other ways.
\-
\-  Basic Latin letters and digits would be confusing nested under =,
\-    escape sequences: Imagine writing "\=,uq x" to unquote the \x
\-    escape sequence. The space in the middle would make the escape
\-    sequence look more tightly joined to its surroundings than to
\-    its own parts.
\-
\-  ~ ! @ # $ % ^ & * _ + { } | : " < > ? are shifted on an American
\-    keyboard, so they're a last resort.
\-
\-  ' is a character we're unlikely to use anytime soon because syntax
\-    highlighters like to think they know what a string looks like.
\-
\-  ` is in a distant corner of the keyboard.
\-
\-  ; visually acts as a hard separator, and we haven't needed that
\-    yet.

<naive non-infix s-expression> ::=
  "[" (<naive non-infix s-expression> | "." | <wsnl>)* "]"
<naive non-infix s-expression> ::=
  "(" (<naive non-infix s-expression> | "." | <wsnl>)* ")"
<naive non-infix s-expression> ::=
  "/" (<naive non-infix s-expression> | "." | <wsnl>)*
  lookahead("]" | ")")
<naive non-infix s-expression> ::=
  (<tx> | <string escape>)+ lookahead(<wsnl> | <other> | <end>)

<s-expression> ::= <s-expression> <rmnl>* "." <non-infix s-expression>
  \- This represents a two-element list.
<s-expression> ::= <non-infix s-expression>
<non-infix s-expression> ::= <rmnl>* <non-infix s-expression>
  \- Ambiguity resolution: Doesn't matter.
<non-infix s-expression> ::= "[" <s-expression>* <rmnl>* "]"
<non-infix s-expression> ::= "(" <s-expression>* <rmnl>* ")"
<non-infix s-expression> ::=
  "/" <s-expression>* <rmnl>* lookahead("]" | ")")
<non-infix s-expression> ::= <tx>+ lookahead(<wsnl> | <other> | <end>)
  \- This represents a string s-expression. It can only express
  \- certain strings.

<non-infix s-expression> ::= "\" <escape>
  \- What this represents varies by the escape sequence.
  \-
  \- When processing an escape sequence, occurrences of whitespace and
  \- comments are ignored, delimiters are normalized, and occurrences
  \- of reader depth modifiers are collected. Occurrences of .
  \- unflatten their s-expressions, but these s-expressions may still
  \- be treated as string data as well.
  \-
  \- \,_ at a depth of 0 unflattens its s-expression, and it
  \-   represents its s-expression value. This is useful because it
  \-   means the code (... \=,qq/\,/a b ...) generates an s-expression
  \-   equivalent to that generated by (... \=,qq/(a b ...)), but
  \-   without requiring an extra ending bracket.
  \-   \-
  \-   \- NOTE: It wouldn't be the same to write (... \=,qq//a b ...)
  \-   \- because / intentionally has no special meaning in a string.
  \-   \- Existing textual syntaxes tend to use / for things like
  \-   \- division, comments, and markup end tags, and if we had a
  \-   \- special meaning for / it would be more cumbersome to
  \-   \- generate these syntaxes.
  \-
  \- \(_) at a depth of 1 represents an interpolated string
  \-   s-expression. The contents are unpeeked. If preformatting is
  \-   off, the string is surrounded by lurking commands to eliminate
  \-   its leading and trailing whitespace. Whether preformatting is
  \-   on or not, the lurking commands in the string are processed.

<top-level s-expression> ::=
  <top-level s-expression> <rm>* "." <non-infix s-expression>
  \- This represents a two-element list.
<top-level s-expression> ::= <non-infix s-expression>

<top level> ::= <top-level s-expression>* <rmnl>*
  \- This unflattens each s-expression, and it represents the sequence
  \- of their s-expression values. This sequence can be parsed
  \- incrementally from first to last.


\- Reader depth modifiers:
\-
\- =,qq (meaning "quasiquote") increases the depth by 1.
\- =,uq (meaning "unquote") decreases the depth by 1.
\- =,(wq _) (meaning "with current quasiquotation level") lets the
\-   given string be bound to the current quasiquotation depth in the
\-   quasiquotation depth environment for as long as the current
\-   quasiquotation depth lasts.
\- =,(lq _ _) (meaning "let quasiquotation level") looks up the
\-   quasiquotation depth the second given string is bound to in the
\-   quasiquotation depth environment, and it lets the first given
\-   string be bound to that quasiquotation depth in the
\-   quasiquotation depth environment for as long as the current
\-   quasiquotation depth lasts.
\- =,(rq _) (meaning "restore quasiquotation level") looks up the
\-   quasiquotation depth the given string is bound to in the
\-   quasiquotation depth environment, and it decreases the
\-   quasiquotation depth to that.

\- NOTE: We give most escape sequences two-letter names because that
\- that's a little more mnemonic than the traditional one-letter
\- names. It also lets us use "l" and "o" without confusing them with
\- digits, lets us avoid resorting to idiosyncratic capitalization,
\- and gives us a four-letter string like "=,pr" we can grep for. For
\- escapes dedicated to single characters, we use short escape
\- sequences with punctuation like "\.<" or letters like "\,t"
\- depending on whether the original character was already
\- punctuation. The substitute punctuation helps it continue to stand
\- out.

\- Whenever an s-expression is unflattened, for the initial state of
\- that unflattening, the quasiquotation depth is 0, the
\- quasiquotation depth environment is empty, and preformatting is
\- off. Until an s-expression is unflattened, it's just treated as
\- string data, and it can contain string escape sequences that
\- wouldn't be valid in an s-expression. This way, an s-expression can
\- be built up by string concatenation.

\- Whenever a delimited sequence of string elements is unpeeked, if
\- any suppressed escape sequence in the string uses a / delimiter
\- that ends at the same place the whole sequence ends, that
\- suppressed / delimiter is converted to a suppressed [ ] or ( )
\- delimiter corresponding to the whole sequence's closing delimiter.
