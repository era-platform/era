"use strict";
var rocketnia = rocketnia || {};
rocketnia.eraFiles = rocketnia.eraFiles || {};
rocketnia.eraFiles[ "era-staccato-lib.stc" ] =
"\\= era-staccato-lib.stc\n\\= Copyright 2015, 2016 Ross Angle. Released under the MIT License.\n\\=\n\\= These are utilities written in a macro layer over Staccato. For\n\\= now, I'm porting the utilities from era-avl.js. (Many of the\n\\= utilities were actually ported from era-staccato-lib.js and\n\\= era-staccato-lib-gensym.js, which were ported from era-avl.js.)\n\\=\n\\= See era-staccato.js for more information about what Staccato is.\n\n\n\\= NOTE: This file depends only on these macros, which are implemented\n\\= in era-staccato-lib-runner.js:\n\\=\n\\= def-type defn case caselet cast isa proj1 c c-new err fn let\n\n\n\\= ===== Lists and boolean tags ======================================\n\n\\= TODO: Put the commented-out types in a separate file so the\n\\= non-mini runner can see them, since it doesn't have them built in.\n\\;rm(def-type cons car cdr)\n\\;rm(def-type yep val)\n\\;rm(def-type nope val)\n\\;rm(def-type nil)\n\n(def-type pair first second)\n\n\\= TODO: Find a better name for this.\n(def-type folding state val)\n\n(defn map-any-foldl state list combiner\n  (cast list cons first rest (folding state list)\n  /caselet combiner-result (c combiner state first)\n    \n    yep result combiner-result\n    \n    folding state first\n    (caselet recur-result (c-new map-any-foldl state rest combiner)\n      yep result recur-result\n      folding state rest (folding state /cons first rest)\n      err.\\;qq[Internal error])\n    \n    err.\\;qq[Expected a combiner-result of type yep or folding]))\n\n(defn map-any list check\n  (caselet fold-result\n    (map-any-foldl (nil) list /fn - elem\n      (caselet check-result (c check elem)\n        yep - check-result\n        nope val (folding (nil) val)\n        err.\\;qq[Expected a check-result of type yep or nope]))\n    yep - fold-result\n    folding - val nope.val\n    err.\\;qq[Internal error]))\n\n(defn any-foldl state list combiner\n  (cast list cons first rest nope.state\n  /caselet combiner-result (c combiner state first)\n    yep result combiner-result\n    nope result (c-new any-foldl result rest combiner)\n    err.\\;qq[Expected a combiner-result of type yep or nope]))\n\n(defn foldl state list combiner\n  (cast list cons first rest state\n  /c-new foldl (c combiner state first) rest combiner))\n\n(defn double-any-foldl state list-a list-b combiner\n  (cast list-a cons first-a rest-a nope.state\n  /cast list-b cons first-b rest-b nope.state\n  /caselet combiner-result (c combiner state first-a first-b)\n    yep result combiner-result\n    nope result (c-new double-any-foldl result list-a list-b combiner)\n    err.\\;qq[Expected a combiner-result of type yep or nope]))\n\n(defn double-foldl state list-a list-b combiner\n  (proj1 nope\n  /double-any-foldl state list-a list-b /fn state elem-a elem-b\n    (nope/c combiner state elem-a elem-b)))\n\n(defn rev-append rev-past rest\n  (foldl rest rev-past /fn state elem /cons elem state))\n\n(defn rev source\n  (rev-append source /nil))\n\n(defn foldr list state combiner\n  (foldl state rev.list /fn state elem /c combiner elem state))\n\n(defn append past rest\n  (rev-append rev.past rest))\n\n(defn map list func\n  (rev/foldl (nil) list /fn state elem /cons (c func elem) state))\n\n(defn mappend list func\n  (rev/foldl (nil) list /fn state elem\n    (rev-append (c func elem) state)))\n\n(defn keep list check\n  (mappend list /fn elem\n    (case (c check elem) yep -\n      (cons elem /nil)\n      (nil))))\n\n(defn any list check\n  (any-foldl (nil) list /fn state elem\n    (caselet check-result (c check elem)\n      yep result check-result\n      nope result (nope/nil)\n      err.\\;qq[Expected a check-result of type yep or nope])))\n\n(defn double-any list-a list-b check\n  (double-any-foldl (nil) list-a list-b /fn state elem-a elem-b\n    (caselet check-result (c check elem-a elem-b)\n      yep result check-result\n      nope result (nope/nil)\n      err.\\;qq[Expected a check-result of type yep or nope])))\n\n(defn not yep-nope\n  (case yep-nope\n    yep val nope.val\n    nope val yep.val\n    err.\\;qq[Expected a yep-nope of type yep or nope]))\n\n(defn or a b\n  (case a yep - a\n  /case b yep - b\n  /nope/nil))\n\n(defn and-lazy a get-b\n  (case a nope - a\n  /let b (c get-b /nil)\n  /case b nope - b\n  /yep/nil))\n\n(defn and a b\n  (and-lazy a /fn - b))\n\n(defn xor a b\n  (case a yep -\n    (case b yep - (nope/nil) a)\n    (case b yep - b (nope/nil))))\n\n(defn yep-nope-swap a b\n  (case a yep - b not.b))\n\n(defn all list check\n  (not/any list /fn elem /not/c check elem))\n\n(def-type rev-cut-result rev-past rest)\n\n(defn maybe-rev-cut list-to-measure-by list-to-cut\n  (case\n    (any-foldl (rev-cut-result (nil) list-to-cut) list-to-measure-by\n    /fn state ignored-elem\n      (cast state rev-cut-result rev-past rest\n        err.\\;qq[Internal error]\n      /cast rest cons first rest (yep/nil)\n      /nope/rev-cut-result (cons first rev-past) rest))\n    yep - (nil)\n    nope rev-cut-result yep.rev-cut-result\n    err.\\;qq[Internal error]))\n\n(defn rev-cut list-to-measure-by list-to-cut\n  (cast (maybe-rev-cut list-to-measure-by list-to-cut) yep result\n    err.\\;qq[\n      Expected a list-to-measure-by no longer than the list-to-cut]\n    result))\n\n(def-type cut-result past rest)\n\n(defn maybe-cut list-to-measure-by list-to-cut\n  (cast (maybe-rev-cut list-to-measure-by list-to-cut)\n    yep rev-cut-result\n    (nil)\n  /cast rev-cut-result rev-cut-result rev-past rest\n    err.\\;qq[Internal error]\n  /yep/cut-result rev.rev-past rest))\n\n(defn cdr list\n  (cast list cons first rest\n    err.\\;qq[Expected a list of type cons]\n    rest))\n\n(defn tails lists\n  (case (all lists /fn list /isa cons list) yep -\n    (c-new tails /map lists /cdr)\n    lists))\n\n\n\\= ===== Lazy lists ==================================================\n\n(def-type lazy-cons get-first get-rest)\n(def-type lazy-nil)\n\n(defn lazy-append a b\n  (cast a lazy-cons a-first a-rest b\n  /lazy-cons a-first /fn - /c-new lazy-append (c a-rest /nil) b))\n\n(defn lazy-any-foldl state lazy-list body\n  (cast lazy-list lazy-cons get-first get-rest nope.state\n  /caselet body-result (c body state /c get-first /nil)\n    yep - body-result\n    nope state (c-new lazy-any-foldl state (c get-rest /nil) body)\n    err.\\;qq[Expected a body-result of type yep or nope]))\n\n(defn lazy-list-compare-by a b elem-compare\n  (cast a lazy-cons a-first a-rest (yep/nil)\n  /cast b lazy-cons b-first b-rest (nope/nil)\n  /caselet comparison\n    (c elem-compare (c a-first /nil) (c b-first /nil))\n    \n    nil\n    (c-new lazy-list-compare-by (c a-rest /nil) (c b-rest /nil)\n      elem-compare)\n    \n    comparison))\n\n\n\\= ===== \"Fixnum operations,\" a generic interface for bigint digits ==\n\n\\= NOTE: Although they're separated into different sections, fixops\n\\= and digpairs are actually interdependent.\n\n(def-type\n  fixops zero one complement compare plus minus times div dual-div)\n(def-type carried main carry)\n\n(defn fixops-zero fixops\n  (cast fixops\n    fixops zero one complement compare plus minus times div dual-div\n    err.\\;qq[Expected a fixops value of type fixops]\n    zero))\n\n(defn fixops-one fixops\n  (cast fixops\n    fixops zero one complement compare plus minus times div dual-div\n    err.\\;qq[Expected a fixops value of type fixops]\n    one))\n\n(defn fixops-complement fixops\n  (cast fixops\n    fixops zero one complement compare plus minus times div dual-div\n    err.\\;qq[Expected a fixops value of type fixops]\n    complement))\n\n(defn fixops-compare fixops\n  (cast fixops\n    fixops zero one complement compare plus minus times div dual-div\n    err.\\;qq[Expected a fixops value of type fixops]\n    compare))\n\n(defn fixops-plus fixops\n  (cast fixops\n    fixops zero one complement compare plus minus times div dual-div\n    err.\\;qq[Expected a fixops value of type fixops]\n    plus))\n\n(defn fixops-minus fixops\n  (cast fixops\n    fixops zero one complement compare plus minus times div dual-div\n    err.\\;qq[Expected a fixops value of type fixops]\n    minus))\n\n(defn fixops-times fixops\n  (cast fixops\n    fixops zero one complement compare plus minus times div dual-div\n    err.\\;qq[Expected a fixops value of type fixops]\n    times))\n\n(defn fixops-div fixops\n  (cast fixops\n    fixops zero one complement compare plus minus times div dual-div\n    err.\\;qq[Expected a fixops value of type fixops]\n    div))\n\n(defn fixops-dual-div fixops\n  (cast fixops\n    fixops zero one complement compare plus minus times div dual-div\n    err.\\;qq[Expected a fixops value of type fixops]\n    dual-div))\n\n(defn fixops-is-zero fixops n\n  (isa nil /fixops-compare fixops fixops-zero.fixops n))\n\n\n\\= ===== \"Digit pairs,\" fixnums built out of two smaller fixnums =====\n\n(def-type digpair fixops is-zero bdig ldig)\n\n(defn make-digpair fixops bdig ldig\n  (let is-zero\n    (and-lazy (fixops-is-zero fixops bdig) /fn -\n      (fixops-is-zero fixops ldig))\n  /digpair fixops is-zero bdig ldig))\n\n(defn digpair-with-digits n bdig ldig\n  (cast n digpair fixops is-zero orig-bdig orig-ldig\n    err.\\;qq[Expected an n value of type digpair]\n  /make-digpair fixops bdig ldig))\n\n(defn digpair-promote-sub n digit\n  (cast n digpair fixops is-zero bdig ldig\n    err.\\;qq[Expected an n value of type digpair]\n  /digpair-with-digits n fixops-zero.fixops digit))\n\n(defn make-fixops-digpair digit-fixops\n  (let zero fixops-zero.digit-fixops\n  /fixops\n    (make-digpair digit-fixops zero zero)\n    (make-digpair digit-fixops zero fixops-one.digit-fixops)\n    c-new.digpair-complement\n    c-new.digpair-compare\n    c-new.digpair-plus\n    c-new.digpair-minus\n    c-new.digpair-times\n    fixops-dual-div.digit-fixops\n    c-new.digpair-dual-div))\n\n(defn digpair-carried-promote carried\n  (cast carried carried n carry\n    err.\\;qq[Expected a carried value of type carried]\n  /cast n digpair fixops is-zero bdig ldig\n    err.\\;qq[Expected an n value of type digpair]\n  /make-digpair make-fixops-digpair.fixops carry n))\n\n(defn digpair-is-zero n\n  (cast n digpair fixops is-zero bdig ldig\n    err.\\;qq[Expected an n value of type digpair]\n    is-zero))\n\n(defn digpair-as-zero n\n  (cast n digpair fixops is-zero bdig ldig\n    err.\\;qq[Expected an n value of type digpair]\n  /case is-zero yep - n\n  /let zero-digit fixops-zero.fixops\n  /digpair-with-digits n zero-digit zero-digit))\n\n(defn digpair-complement n\n  (cast n digpair fixops is-zero bdig ldig\n    err.\\;qq[Expected an n value of type digpair]\n  /digpair-with-digits n\n    (fixops-complement fixops bdig)\n    (fixops-complement fixops ldig)))\n\n(defn digpair-compare n m\n  (cast n digpair fixops n-is-zero n-bdig n-ldig\n    err.\\;qq[Expected an n value of type digpair]\n  /cast m digpair - m-is-zero m-bdig m-ldig\n    err.\\;qq[Expected an m value of type digpair]\n  \\= Optimization: If either thing to compare is zero, we can avoid\n  \\= iterating over the digits.\n  /case n-is-zero yep -\n    (case m-is-zero yep -\n      (nil)\n      (yep/nil))\n  /case m-is-zero yep -\n    (nope/nil)\n  /caselet bcompare (fixops-compare fixops n-bdig m-bdig) nil\n    (fixops-compare n-ldig n-bdig)\n    bcompare))\n\n(defn digpair-plus n m-carried\n  (cast n digpair fixops n-is-zero n-bdig n-ldig\n    err.\\;qq[Expected an n value of type digpair]\n  /cast m-carried carried m carry\n    err.\\;qq[Expected an m-carried value of type carried]\n  /cast m digpair - m-is-zero m-bdig m-ldig\n    err.\\;qq[Expected an m value of type digpair]\n  /cast carry digpair - carry-is-zero -b cdig\n    err.\\;qq[Expected a carry value of type digpair]\n  \n  \\= Optimization: If either summand is zero and the carry is also\n  \\= zero, we can just use the other as the result.\n  /case (and n-is-zero carry-is-zero) yep - (carried m carry)\n  /case (and m-is-zero carry-is-zero) yep - (carried n carry)\n  \n  /cast (fixops-plus fixops n-ldig /carried m-ldig cdig)\n    carried r-ldig cdig\n    err.\\;qq[Internal error]\n  /cast (fixops-plus fixops n-bdig /carried m-bdig cdig)\n    carried r-bdig cdig\n    err.\\;qq[Internal error]\n  /carried (digpair-with-digits n r-bdig r-ldig)\n  /digpair-promote-sub n cdig))\n\n(defn digpair-minus n m-carried\n  (cast n digpair fixops n-is-zero n-bdig n-ldig\n    err.\\;qq[Expected an n value of type digpair]\n  /cast m-carried carried m carry\n    err.\\;qq[Expected an m-carried value of type carried]\n  /cast m digpair - m-is-zero m-bdig m-ldig\n    err.\\;qq[Expected an m value of type digpair]\n  /cast carry digpair - carry-is-zero -b cdig\n    err.\\;qq[Expected a carry value of type digpair]\n  \n  \\= Optimization: If both things to subtract from this are zero, we\n  \\= can just skip the subtraction.\n  /case (and m-is-zero carry-is-zero) yep - (carried n carry)\n  \n  /cast (fixops-minus fixops n-ldig /carried m-ldig cdig)\n    carried r-ldig cdig\n    err.\\;qq[Internal error]\n  /cast (fixops-minus fixops n-bdig /carried m-bdig cdig)\n    carried r-bdig cdig\n    err.\\;qq[Internal error]\n  /carried (digpair-with-digits n r-bdig r-ldig)\n  /digpair-promote-sub n cdig))\n\n(defn digpair-times-small n m-carried\n  (cast n digpair fixops n-is-zero n-bdig n-ldig\n    err.\\;qq[Expected an n value of type digpair]\n  /cast m-carried carried m carry\n    err.\\;qq[Expected an m-carried value of type carried]\n  /let carry-is-zero (fixops-is-zero fixops carry)\n  \n  \\= Optimization: If either factor is zero and the carry is also\n  \\= zero, we can just use a result of zero.\n  /case (and n-is-zero carry-is-zero) yep - (carried n carry)\n  \n  /case (and (fixops-is-zero fixops m) carry-is-zero) yep -\n    (carried digpair-as-zero.n carry)\n  /cast (fixops-times fixops n-ldig /carried m carry)\n    carried r-ldig carry\n    err.\\;qq[Internal error]\n  /cast (fixops-times fixops n-bdig /carried m carry)\n    carried r-bdig carry\n    err.\\;qq[Internal error]\n  /carried (digpair-with-digits n r-bdig r-ldig) carry))\n\n(defn digpair-times n m-carried\n  (cast n digpair fixops n-is-zero n-bdig n-ldig\n    err.\\;qq[Expected an n value of type digpair]\n  \\= TODO: See if this can be more efficient.\n  /cast m-carried carried m carry\n    err.\\;qq[Expected an m-carried value of type carried]\n  /cast m digpair - m-is-zero m-bdig m-ldig\n    err.\\;qq[Expected an m value of type digpair]\n  \n  \\= Optimization: If either factor is zero, we can just use the\n  \\= carry as the result value.\n  /case n-is-zero yep - (carried carry n)\n  /case m-is-zero yep - (carried carry m)\n  \n  /let zero digpair-as-zero.carry\n  /let zero-digit fixops-zero.fixops\n  /let big-carry (make-digpair zero zero carry)\n  /let digit-times\n    (fn a b /fixops-times fixops a /carried b zero-digit)\n  /let plus-no-carry\n    (fn a b\n      (case (fixops-plus fixops a /carried b zero-digit)\n        carried sum carry sum\n        err.\\;qq[Internal error]))\n  /let four-digit\n    (fn a b c d\n      (make-digpair zero\n        (make-digpair zero-digit a b)\n        (make-digpair zero-digit c d)))\n  /let r-ll\n    (cast (c digit-times n-ldig m-ldig) carried dig carry\n      err.\\;qq[Internal error]\n    /c four-digit zero-digit zero-digit carry dig)\n  /let r-lb\n    (cast (c digit-times n-ldig m-bdig) carried dig carry\n      err.\\;qq[Internal error]\n    /c four-digit zero-digit carry dig zero-digit)\n  /let r-bl\n    (cast (c digit-times n-bdig m-ldig) carried dig carry\n      err.\\;qq[Internal error]\n    /c four-digit zero-digit carry dig zero-digit)\n  /let r-bb\n    (cast (c digit-times n-bdig m-bdig) carried dig carry\n      err.\\;qq[Internal error]\n    /c four-digit carry dig zero-digit zero-digit)\n  \n  \\= NOTE: When the digits are 16-bit, the maximum value of `carry` is\n  \\= 0xFFFFFFFF, and the maximum value of `n` times `m` plus the carry\n  \\= is 0xFFFFFFFF00000000, so there's no excess.\n  /cast\n    (c plus-no-carry r-ll\n    /c plus-no-carry r-lb\n    /c plus-no-carry r-bl\n    /c plus-no-carry r-bb\n    /make-digpair zero zero carry)\n    \n    digpair fixops is-zero bdig ldig\n    err.\\;qq[Internal error]\n  /carried ldig bdig))\n\n(defn digpair-div-small n m-carried\n  (cast n digpair fixops n-is-zero n-bdig n-ldig\n    err.\\;qq[Expected an n value of type digpair]\n  /cast m-carried carried m carry\n    err.\\;qq[Expected an m-carried value of type carried]\n  /cast (fixops-is-zero fixops m) yep -\n    err.\\;qq[Called digpair-div-small with a zero divisor]\n  /let carry-is-zero (fixops-is-zero fixops carry)\n  \n  \\= Optimization: If the dividend is zero and the carry is also zero,\n  \\= we can just use a result of zero.\n  /case (and n-is-zero carry-is-zero) yep - (carried n carry)\n  \n  /cast (fixops-div fixops n-bdig /carried m carry)\n    carried r-bdig carry\n    err.\\;qq[Internal error]\n  /cast (fixops-div fixops n-ldig /carried m carry)\n    carried r-ldig carry\n    err.\\;qq[Internal error]\n  /carried (digpair-with-digits n r-bdig r-ldig) carry))\n\n(defn digpair-dual-div-no-carry n3210 m3210\n  (let long-zero digpair-as-zero.n3210\n  /cast long-zero digpair long-fixops - -b short-zero\n    err.\\;qq[Internal error]\n  /let make-short (fn a b /digpair-with-digits short-zero a b)\n  /let long-one\n    (digpair-with-digits long-zero short-zero fixops-one.long-fixops)\n  /let four-digits\n    (fn a b c d\n      (digpair-with-digits long-zero\n        (c make-short a b)\n        (c make-short c d)))\n  /case (digpair-compare n3210 m3210) yep -\n    err.\\;qq[\n      Called digpair-dual-div-no-carry with a smaller dividend than\n      divisor]\n  /cast n3210 digpair - -b n32 n10\n    err.\\;qq[Expected an n3210 value of type digpair]\n  /cast m3210 digpair - -b m32 m10\n    err.\\;qq[Expected an m3210 value of type digpair]\n  /case digpair-is-zero.m32 yep -\n    err.\\;qq[Called digpair-dual-div-no-carry with a zero m32]\n  /cast n32 digpair digit-fixops - n3 n2\n    err.\\;qq[Expected an n32 value of type digpair]\n  /cast n10 digpair - -b n1 n0\n    err.\\;qq[Expected an n10 value of type digpair]\n  /cast m32 digpair - -b m3 m2\n    err.\\;qq[Expected an m32 value of type digpair]\n  /cast m10 digpair - -b m1 m0\n    err.\\;qq[Expected an m10 value of type digpair]\n  /let zdig fixops-zero.digit-fixops\n  /let ignore-carry\n    (fn carried\n      (case carried carried result carry\n        result\n        err.\\;qq[Internal error]))\n  /let mid1-result\n    \\= We ignore the remainder because we're just going to calculate a\n    \\= more accurate remainder by multiplying the full-precision\n    \\= divisor.\n    (c ignore-carry /c-new digpair-dual-div\n      (c four-digits zdig n3 n2 n1)\n    /carried\n      \\= We ignore the carry because it must be zero.\n      (c ignore-carry /digpair-plus long-one\n      /c four-digits zdig m3 m2 m1)\n      long-zero)\n  /let mid1-remainder\n    \\= We ignore the subtraction carry because it must be zero.\n    (c ignore-carry /digpair-minus n3210\n    /carried\n      \\= We ignore the multiplication carry because it must be zero.\n      (c ignore-carry /digpair-times m3210\n      /carried mid1-result long-zero)\n      long-zero)\n  \n  \\= At this point, we might be *one* subtraction away from a fully\n  \\= accurate result. (We can't be two or more subtractions away,\n  \\= since the approximate divisor would have been small enough to fit\n  \\= in the space of twice the accurate divisor. After all, the\n  \\= approximate divisor is only too large by (1 + maxDigitValue) or\n  \\= less, and we already know the divisor is at least\n  \\= (1 + maxDigitValue)^2.) So, we do that subtraction if possible.\n  \\=\n  /case (digpair-compare mid1-remainder m3210) yep -\n    (carried mid1-result mid1-remainder)\n    (carried\n      \n      \\= We ignore the carry because it must be zero.\n      (c ignore-carry /digpair-plus mid1-result\n      /carried long-one long-zero)\n      \n      \\= We ignore the carry because it must be zero.\n      (c ignore-carry /digpair-minus mid1-remainder\n      /carried m3210 long-zero))))\n\n(defn digpair-dual-div n m-carried\n  \\= TODO: See if this can be more efficient.\n  (cast n digpair fixops n-is-zero n-bdig n-ldig\n    err.\\;qq[Expected an n value of type digpair]\n  /cast m-carried carried m carry\n    err.\\;qq[Expected an m-carried value of type carried]\n  /cast m digpair - m-is-zero m-bdig m-ldig\n    err.\\;qq[Expected an m value of type digpair]\n  /case m-is-zero yep -\n    err.\\;qq[Called digpair-dual-div with a zero divisor]\n  /cast carry digpair - carry-is-zero c-bdig c-ldig\n    err.\\;qq[Expected a carry value of type digpair]\n  /let zdig fixops-zero.fixops\n  /case carry-is-zero yep -\n    \n    \\= If the carry is zero and the dividend is less than the divisor,\n    \\= we return zero and a remainder equal to the dividend.\n    (case (fixops-compare fixops n m) yep -\n      (carried digpair-as-zero.n n)\n    \n    \\= If the carry is zero and the first digit of the divisor is\n    \\= zero, we can reduce this division to a division of the digits.\n    /case (fixops-is-zero fixops m-bdig) yep -\n      (cast (fixops-dual-div fixops n-bdig /carried m-ldig zdig)\n        carried r-bdig intermediate1-carry\n        err.\\;qq[Internal error]\n      /cast\n        (fixops-dual-div fixops n-ldig\n        /carried m-ldig intermediate1-carry)\n        carried r-ldig carry\n        err.\\;qq[Internal error]\n      /carried (digpair-with-digits n r-bdig r-ldig)\n      /digpair-with-digits zdig carry)\n    \n    \\= If the carry is zero, if the divisor is less than or equal to\n    \\= the dividend, and if the first digit of the divisor isn't zero,\n    \\= then we split the digits into sub-digits and divide by an\n    \\= approximation where we drop the least significant sub-digits.\n    \\= The approximation may be off by one, so we check for this and\n    \\= subtract one more time if necessary. We handle this in a\n    \\= separate function.\n    /digpair-dual-div-no-carry fixops n m)\n  \n  \\= If the carry isn't zero, we shift the carry-and-divisor\n  \\= combination down by one digit, do a division from there, and then\n  \\= do another division to account for the digit that was dropped.\n  \\= This means the carry-and-divisor combination will have one fewer\n  \\= nonzero digit, and it will take no more than two of these\n  \\= reductions to wind up at the carry-is-zero case.\n  /cast\n    (c-new digpair-dual-div (digpair-with-digits n c-ldig n-bdig)\n    /carried m (digpair-with-digits n zdig c-bdig))\n    carried intermediate1-result intermediate1-carry\n    err.\\;qq[Internal error]\n  /cast intermediate1-result digpair - -b -c ir-ldig\n    err.\\;qq[Internal error]\n  /cast intermediate1-carry digpair - -b ic-bdig ic-ldig\n    err.\\;qq[Internal error]\n  /cast\n    (c-new digpair-dual-div (digpair-with-digits n ic-ldig n-ldig)\n    /carried m (digpair-with-digits n zdig ic-bdig))\n    carried intermediate2-result carry\n    err.\\;qq[Internal error]\n  /cast\n    (digpair-plus (digpair-with-digits ir-ldig zdig)\n    /carried intermediate2-result digpair-as-zero.n)\n    carried result -\n    err.\\;qq[Internal error]\n  /carried result carry))\n\n\n\\= ===== One-bit fixnums in terms of (yep/nil) and (nope/nil) ========\n\n(defn make-fixops-yep-nope -\n  (fixops\n    (nope/nil)\n    (yep/nil)\n    (not)\n    \n    (fn n m\n      \\= Compare\n      (case n yep -\n        (case m yep - (nil) (nope/nil))\n        (case m yep - (yep/nil) (nil))))\n    \n    (fn n m-carried\n      \\= Plus\n      (cast m-carried carried m carry\n        err.\\;qq[Expected an m-carried value of type carried]\n      /case (xor n m) yep -\n        (carried not.carry carry)\n        (carried carry n)))\n    \n    (fn n m-carried\n      \\= Minus\n      (cast m-carried carried m carry\n        err.\\;qq[Expected an m-carried value of type carried]\n      /case (xor n m) yep -\n        (carried not.carry m)\n        (carried carry carry)))\n    \n    (fn n m-carried\n      \\= Times\n      (cast m-carried carried m carry\n        err.\\;qq[Expected an m-carried value of type carried]\n      /case (and n m) yep -\n        (carried not.carry carry)\n        (carried carry /nope/nil)))\n    \n    (fn n m-carried\n      \\= Div\n      (cast m-carried carried m carry\n        err.\\;qq[Expected an m-carried value of type carried]\n      /case m nope -\n        \\= Divide by zero.\n        err.\\;qq[\n          Called make-fixops-yep-nope's div operation with a zero\n          divisor]\n      \\= Divide by one.\n      /carried n carry))\n    \n    (fn n m-carried\n      \\= Dual-div\n      (cast n digpair - n-is-zero n1 n0\n        err.\\;qq[Expected an n value of type digpair]\n      /cast m-carried carried m carry\n        err.\\;qq[Expected an m-carried value of type carried]\n      /cast m digpair - m-is-zero m1 m0\n        err.\\;qq[Expected an m value of type digpair]\n      /cast carry digpair - carry-is-zero n3 n2\n        err.\\;qq[Expected a carry value of type digpair]\n      /case m-is-zero yep -\n        \\= Divide by zero.\n        err.\\;qq[\n          Called make-fixops-yep-nope's dual-div operation with a zero\n          divisor]\n      /case (and not.m1 m0) yep -\n        \\= Divide by one.\n        (carried n carry)\n      /case not.m0 yep -\n        \\= Divide by two.\n        (carried (digpair-with-digits n n2 n1)\n        /digpair-with-digits n (nope/nil) n0)\n      \n      \\= Divide by three.\n      /let r1 (or n3 /and n2 n1)\n      /let n2b (case r1 nope - n2 /and n3 n1)\n      /let n1b (case r1 nope - n1 not.n1)\n      /let n0b n0\n      /let r0 (or n2b /and n1b n0b)\n      /carried (digpair-with-digits n r1 r0)\n      /digpair-with-digits n\n        (case r0 nope - n1b /and n2b n0b)\n        (case r0 nope - n0b not.n0b)))))\n\n\n\\= ===== Big, zero-based natural numbers =============================\n\n(def-type binat-internals depth fixnum)\n(def-type binat fixops maybe-internals)\n\n(defn binat-zero-for-fixops fixops\n  (binat fixops /nil))\n\n(defn binat-as-zero n\n  (cast n binat fixops n-internals\n    err.\\;qq[Expected an n value of type binat]\n    binat-zero-for-fixops.fixops))\n\n(defn binat-as-one n\n  (cast n binat fixops n-internals\n    err.\\;qq[Expected an n value of type binat]\n  /binat fixops\n  /binat-internals (binat fixops /nil) fixops-one.fixops))\n\n(defn binat-is-zero n\n  (cast n binat fixops n-internals\n    err.\\;qq[Expected an n value of type binat]\n  /not/isa binat-internals n-internals))\n\n(defn improper-binat-is-zero n\n  (cast n binat fixops n-internals\n    err.\\;qq[Expected an n value of type binat]\n  /case n-internals binat-internals depth fixnum\n    (case binat-is-zero.depth yep -\n      (fixops-is-zero fixops fixnum)\n      digpair-is-zero.fixnum)\n    (yep/nil)))\n\n(defn binat-compare n m\n  (cast n binat fixops n-internals\n    err.\\;qq[Expected an n value of type binat]\n  /cast m binat - m-internals\n    err.\\;qq[Expected an m value of type binat]\n  /case n-internals binat-internals n-depth nfix\n    (case m-internals binat-internals m-depth mfix\n      (caselet depth-comparison (c-new binat-compare n-depth m-depth)\n        nil\n        (case binat-is-zero.n-depth yep -\n          (fixops-compare fixops nfix mfix)\n          (digpair-compare nfix mfix))\n        depth-comparison)\n      (nope/nil))\n    (case m-internals binat-internals - -b\n      (yep/nil)\n      (nil))))\n\n(defn improper-binat-reduce n\n  (cast n binat fixops n-internals\n    err.\\;qq[Expected an n value of type binat]\n  /cast n-internals binat-internals depth fixnum\n    n\n  /case binat-is-zero.depth yep -\n    (case (fixops-is-zero fixops fixnum) yep -\n      binat-as-zero.n\n      n)\n  /cast fixnum digpair digit-fixops is-zero bdig ldig\n    err.\\;qq[Expected a fixnum value of type digpair]\n  /case is-zero yep -\n    binat-as-zero.n\n  /case (fixops-is-zero digit-fixops bdig) nope -\n    n\n  /c-new improper-binat-reduce\n  /binat fixops\n  /binat-internals\n    (case (c-new binat-subtracted-from binat-as-one.depth depth)\n      yep depth-minus-one depth-minus-one\n      nil binat-as-zero.depth\n      err.\\;qq[Internal error])\n    ldig))\n\n(defn improper-binat-promote-carried fixops depth carried\n  (cast carried carried result carry\n    err.\\;qq[Expected a carried value of type carried]\n  /case\n    (case binat-is-zero.depth yep -\n      (fixops-is-zero fixops carry)\n      digpair-is-zero.carry)\n    \n    yep - (binat fixops /binat-internals depth result)\n    \n    (binat fixops\n    /binat-internals (c-new binat-plus depth binat-as-one.depth)\n      digpair-carried-promote.carried)))\n\n(defn improper-binat-promote n\n  (cast n binat fixops n-internals\n    err.\\;qq[Expected an n value of type binat]\n  /cast n-internals binat-internals depth fixnum\n    err.\\;qq[Expected an n value that wasn't zero]\n  /binat fixops\n  /binat-internals (c-new binat-plus depth binat-as-one.depth)\n  /case binat-is-zero.depth yep -\n    (make-digpair\n      make-fixops-digpair.fixops fixops-zero.fixops fixnum)\n    (digpair-carried-promote/carried fixnum digpair-as-zero.fixnum)))\n\n(defn improper-binat-plus n m\n  (cast n binat fixops n-internals\n    err.\\;qq[Expected an n value of type binat]\n  /cast m binat - m-internals\n    err.\\;qq[Expected an m value of type binat]\n  /cast n-internals binat-internals n-depth nfix\n    m\n  /cast m-internals binat-internals m-depth mfix\n    n\n  /case (binat-compare n-depth m-depth)\n    yep - (c-new improper-binat-plus improper-binat-promote.n m)\n    nope - (c-new improper-binat-plus n improper-binat-promote.m)\n  /improper-binat-promote-carried fixops n-depth\n  /case binat-is-zero.n-depth yep -\n    (fixops-plus fixops nfix /carried mfix fixops-zero.fixops)\n    (digpair-plus nfix /carried mfix digpair-as-zero.nfix)))\n\n(defn binat-plus m n\n  (improper-binat-plus m n))\n\n(defn improper-binat-subtracted-from n m\n  (case (binat-compare n m)\n    nil (nil)\n    nope - (not/c-new improper-binat-subtracted-from m n)\n  /cast n binat fixops n-internals\n    err.\\;qq[Expected an n value of type binat]\n  /cast m binat - m-internals\n    err.\\;qq[Expected an m value of type binat]\n  /cast n-internals binat-internals n-depth nfix\n    yep.m\n  /cast m-internals binat-internals m-depth mfix\n    err.\\;qq[Internal error]\n  /case (binat-compare n-depth m-depth) yep -\n    (c-new improper-binat-subtracted-from improper-binat-promote.n m)\n  /cast\n    (case binat-is-zero.n-depth yep -\n      (fixops-minus fixops mfix /carried nfix fixops-zero.fixops)\n      (digpair-minus mfix /carried nfix digpair-as-zero.nfix))\n    carried result carry\n    err.\\;qq[Internal error]\n  /nope/binat fixops /binat-internals n-depth result))\n\n(defn binat-subtracted-from m n\n  (case (improper-binat-subtracted-from m n)\n    yep result (yep improper-binat-reduce.result)\n    nope result (nope improper-binat-reduce.result)\n  /nil))\n\n(defn improper-binat-times n m\n  (cast n binat fixops n-internals\n    err.\\;qq[Expected an n value of type binat]\n  /cast m binat - m-internals\n    err.\\;qq[Expected an m value of type binat]\n  /cast n-internals binat-internals n-depth nfix\n    n\n  /cast m-internals binat-internals m-depth mfix\n    m\n  /case (binat-compare n-depth m-depth)\n    yep - (c-new improper-binat-times improper-binat-promote.n m)\n    nope - (c-new improper-binat-times n improper-binat-promote.m)\n  /improper-binat-promote-carried fixops n-depth\n  /case binat-is-zero.n-depth yep -\n    (fixops-times fixops nfix /carried mfix fixops-zero.fixops)\n    (digpair-times nfix /carried mfix digpair-as-zero.nfix)))\n\n(defn binat-times m n\n  (improper-binat-reduce/improper-binat-times m n))\n\n(defn improper-binat-div n m\n  (case (binat-compare n m)\n    nil (carried binat-as-one.n binat-as-zero.n)\n    yep - (carried binat-as-zero.n n)\n  /case improper-binat-is-zero.m yep -\n    err.\\;qq[Called improper-binat-div with a zero divisor]\n  /cast n binat fixops n-internals\n    err.\\;qq[Expected an n value of type binat]\n  /cast m binat - m-internals\n    err.\\;qq[Expected an m value of type binat]\n  /cast n-internals binat-internals n-depth nfix\n    err.\\;qq[Internal error]\n  /cast m-internals binat-internals m-depth mfix\n    err.\\;qq[Internal error]\n  /case (binat-compare n-depth m-depth) nope -\n    (c-new improper-binat-div n improper-binat-promote.m)\n  /cast\n    (case binat-is-zero.n-depth yep -\n      (fixops-div fixops nfix /carried mfix fixops-zero.fixops)\n    /case (binat-compare n-depth binat-as-one.n-depth) nil\n      (fixops-dual-div fixops nfix /carried mfix digpair-as-zero.nfix)\n      (digpair-dual-div nfix /carried mfix digpair-as-zero.nfix))\n    carried result carry\n    err.\\;qq[Internal error]\n  /carried (binat fixops /binat-internals n-depth result)\n  /binat fixops /binat-internals n-depth carry))\n\n(defn binat-div m n\n  (cast (improper-binat-div m n) carried result carry\n    err.\\;qq[Internal error]\n  /carried improper-binat-reduce.result improper-binat-reduce.carry))\n\n\n\\= ===== Big signed integers =========================================\n\\=\n\\= These might even be integers that carry a big sign. You can't say\n\\= they aren't.\n\n(def-type bigint fixops nat)\n\n(defn bigint-zero-for-fixops fixops\n  (bigint fixops /nil))\n\n(defn bigint-as-zero n\n  (cast n bigint fixops n-nat\n    err.\\;qq[Expected an n value of type bigint]\n    bigint-zero-for-fixops.fixops))\n\n(defn bigint-as-one n\n  (cast n bigint fixops n-nat\n    err.\\;qq[Expected an n value of type bigint]\n  /bigint fixops /yep/binat-as-one binat-zero-for-fixops.fixops))\n\n(defn bigint-neg n\n  (cast n bigint fixops n-nat\n    err.\\;qq[Expected an n value of type bigint]\n  /case n-nat nil\n    n\n  /bigint fixops not.n))\n\n(defn bigint-abs n\n  (cast n bigint fixops n-nat\n    err.\\;qq[Expected an n value of type bigint]\n  /case n-nat nope -\n    bigint-neg.n\n    n))\n\n(defn bigint-compare n m\n  (cast n bigint - n\n    err.\\;qq[Expected an n value of type bigint]\n  /cast m bigint - m\n    err.\\;qq[Expected an m value of type bigint]\n  /case n\n    \n    yep n\n    (case m yep m\n      (binat-compare n m)\n      (nope/nil))\n    \n    nope n\n    (case m nope m\n      (binat-compare m n)\n      (yep/nil))\n    \n  /case m\n    yep - (yep/nil)\n    nope - (nope/nil)\n    (nil)))\n\n(defn bigint-is-zero n\n  (isa nil /bigint-compare n bigint-as-zero.n))\n\n(defn bigint-plus n m\n  (cast n bigint fixops n\n    err.\\;qq[Expected an n value of type bigint]\n  /cast m bigint - m\n    err.\\;qq[Expected an m value of type bigint]\n  /case n\n    \n    yep n\n    (case m\n      yep m (bigint fixops /yep/binat-plus n m)\n      nope m (bigint fixops /binat-subtracted-from m n)\n    /bigint fixops n)\n    \n    nope n\n    (case m\n      yep m (bigint fixops /binat-subtracted-from n m)\n      nope m (bigint fixops /nope/binat-plus n m)\n    /bigint fixops n)\n    \n  /bigint fixops m))\n\n(defn bigint-minus n m\n  (bigint-plus n bigint-neg.m))\n\n(defn bigint-times n m\n  (cast n bigint fixops n\n    err.\\;qq[Expected an n value of type bigint]\n  /cast m bigint - m\n    err.\\;qq[Expected an m value of type bigint]\n  /case n\n    \n    yep n\n    (case m\n      yep m (bigint fixops /yep/binat-times n m)\n      nope m (bigint fixops /nope/binat-times m n)\n    /bigint fixops /nil)\n    \n    nope n\n    (case m\n      yep m (bigint fixops /nope/binat-times n m)\n      nope m (bigint fixops /yep/binat-times n m)\n    /bigint fixops /nil)\n    \n  /bigint fixops /nil))\n\n(defn bigint-div-toward-zero n m\n  (let pos (fn n yep.n)\n  /let neg (fn n nope.n)\n  /cast n bigint fixops n\n    err.\\;qq[Expected an n value of type bigint]\n  /cast m bigint - m\n    err.\\;qq[Expected an m value of type bigint]\n  /let div\n    (fn n m result-sign carry-sign\n      (cast (binat-div n m) carried result carry\n        err.\\;qq[Internal error]\n      /bigint fixops\n      /carried (bigint fixops /c result-sign result)\n      /bigint fixops /c carry-sign carry))\n  \n  \\= NOTE: These examples may clarify the following signs.\n  \\=\n  \\=   9  /   2  =   4  R   1  because   9  =   2  *   4  +   1\n  \\=   9  /  -2  =  -4  R   1  because   9  =  -2  *  -4  +   1\n  \\=  -9  /   2  =  -4  R  -1  because  -9  =   2  *  -4  +  -1\n  \\=  -9  /  -2  =   4  R  -1  because  -9  =  -2  *   4  +  -1\n  \n  /case n\n    \n    yep n\n    (case m\n      yep m (c div n m pos pos)\n      nope m (c div n m neg pos)\n      err.\\;qq[Called bigint-div-toward-zero with a zero divisor])\n    \n    nope n\n    (case m\n      yep m (c div n m neg neg)\n      nope m (c div n m pos neg)\n      err.\\;qq[Called bigint-div-toward-zero with a zero divisor])\n  \n  /bigint fixops /nil))\n\n\\= TODO: Port toStringInRadix and bigIntFromStringInRadix. We don't\n\\= have string manipulation yet, though.\n\n\n\\= ===== AVL trees ===================================================\n\n\\= TODO: See if our use of binary bigints is less efficient than\n\\= era-avl.js's use of unary bigints.\n\n(def-type avl-leaf fixops compare)\n(def-type\n  avl-branches nope-unbalance nope-branch yep-unbalance yep-branch)\n(def-type avl-branch fixops compare key val branches)\n(def-type depth-modified depth-was-modified result)\n\n(defn avl-branches-swap polarity branches\n  (case polarity yep - branches\n  /cast branches avl-branches nub nbranch yub ybranch\n    err.\\;qq[Expected a branches value of type avl-branches]\n  /avl-branches yub ybranch nub nbranch))\n\n(defn avl-comparer tree\n  (case tree avl-leaf fixops compare compare\n  /case tree avl-branch fixops compare key val branches compare\n    err.\\;qq[Expected a tree value of type avl-leaf or avl-branch]))\n\n(defn avl-get-maybe tree k\n  (case tree avl-leaf fixops compare\n    (nil)\n  /case tree avl-branch fixops compare key val branches\n    (cast branches avl-branches nub nbranch yub ybranch\n      err.\\;qq[Expected a branches value of type avl-branches]\n    /case (c compare key k)\n      nope - (c-new avl-get-maybe nbranch k)\n      yep - (c-new avl-get-maybe ybranch k)\n      yep.val)\n    err.\\;qq[Expected a tree value of type avl-leaf or avl-branch]))\n\n(def-type\n  depth-changed nope-depth-change yep-depth-change balanced-tree)\n\n(defn depth-changed-swap polarity balance-result\n  (case polarity yep - balance-result\n  /cast balance-result\n    depth-changed nope-depth-change yep-depth-change balanced-tree\n    err.\\;qq[Expected a balance-result value of type depth-changed]\n  /depth-changed yep-depth-change nope-depth-change balanced-tree))\n\n(def-type avl-minus-extreme-entry-succeeded\n  max-depth-decreased k v tree-remaining)\n\n(defn improper-avl-branch-balance tree\n  (cast tree avl-branch fixops compare key val branches\n    err.\\;qq[Expected a tree value of type avl-branch]\n  /cast branches avl-branches nub nbranch yub ybranch\n    err.\\;qq[Expected a branches value of type avl-branches]\n  /let bigint-minus-one (fn n /bigint-minus n bigint-as-one.n)\n  /let bigint-plus-one (fn n /bigint-plus n bigint-as-one.n)\n  /let bigint-lteq-one\n    (fn n\n      (not/isa nope /bigint-compare n bigint-as-one.n))\n  /let n-is-zero bigint-is-zero.nub\n  /let y-is-zero bigint-is-zero.yub\n  /case (or n-is-zero y-is-zero) nope -\n    (c-new improper-avl-branch-balance\n    /avl-branch fixops compare key val\n    /avl-branches\n      (c bigint-minus-one nub) nbranch\n      (c bigint-minus-one yub) ybranch)\n  /case\n    (and-lazy (c bigint-lteq-one nub) /fn - (c bigint-lteq-one yub))\n    yep -\n    (let zero bigint-zero-for-fixops.fixops\n    /depth-changed zero zero tree)\n  /let polarity y-is-zero\n  /cast (avl-branches-swap polarity branches)\n    avl-branches wub wbranch tub tbranch\n    err.\\;qq[Internal error]\n  /cast (c-new avl-minus-extreme-entry wbranch polarity)\n    avl-minus-extreme-entry-succeeded\n    max-depth-decreased k v wbranch\n    err.\\;qq[Internal error]\n  /cast\n    (case (c-new avl-plus-entry tbranch key val)\n      nope result (pair (nope/nil) result)\n      yep result (pair (yep/nil) result)\n      err.\\;qq[Internal error])\n    pair max-depth-increased tbranch\n    err.\\;qq[Internal error]\n  /let wub\n    (case max-depth-decreased yep - (c bigint-minus-one wub) wub)\n  /let wub\n    (case max-depth-increased yep - (c bigint-minus-one wub) wub)\n  /cast\n    (depth-changed-swap polarity\n    /c-new improper-avl-branch-balance /avl-branch fixops compare k v\n    /avl-branches-swap polarity\n    /avl-branches wub wbranch tub tbranch)\n    depth-changed w-depth-change t-depth-change tree\n    err.\\;qq[Internal error]\n  /let w-depth-change\n    (case max-depth-decreased yep -\n      (c bigint-minus-one w-depth-change)\n      w-depth-change)\n  /let t-depth-change\n    (case max-depth-decreased yep -\n      (c bigint-plus-one t-depth-change)\n      t-depth-change)\n  /depth-changed-swap polarity\n  /depth-changed w-depth-change t-depth-change tree))\n\n(defn avl-branch-finish-minus fixops compare branches\n  \\= NOTE: This effectively concatenates the branches. Like\n  \\= `improper-avl-branch-balance`, this assumes all the elements are\n  \\= already in the proper order, just not necessarily balanced\n  \\= between the two branches. It's not a merge of arbitrary trees.\n  \\= For that, see `avl-merge`. Furthermore, this can even rely on the\n  \\= fact that the branches were initially balanced before the root\n  \\= key/value entry was subtracted from the tree.\n  (cast branches avl-branches nub nbranch yub ybranch\n    err.\\;qq[Expected a branches value of type avl-branches]\n  /let attempt-shift\n    (fn polarity on-fail\n      (cast (avl-branches-swap polarity branches)\n        avl-branches wub wbranch tub tbranch\n        err.\\;qq[Internal error]\n      /case (c-new avl-minus-extreme-entry wbranch polarity)\n        \n        nope - (c on-fail /nil)\n        \n        avl-minus-extreme-entry-succeeded\n        max-depth-decreased k v tree-remaining\n        (let inc (fn n /bigint-plus n bigint-as-one.n)\n        /let new-tub\n          (case max-depth-decreased yep -\n            (c inc tub)\n            tub)\n        /cast\n          (depth-changed-swap polarity\n          /improper-avl-branch-balance/avl-branch fixops compare k v\n          /avl-branches-swap polarity\n          /avl-branches wub wbranch new-tub tbranch)\n          depth-changed w-depth-change t-depth-change tree\n          err.\\;qq[Internal error]\n        /yep-nope-swap\n          (and-lazy max-depth-decreased /fn -\n          /and-lazy (not bigint-is-zero.tub) /fn -\n            (not/isa yep /bigint-compare bigint-as-zero.w-depth-change\n              w-depth-change))\n          tree)\n        \n        err.\\;qq[Internal error]))\n  \n  /c attempt-shift (yep/nil) /fn -\n  /c attempt-shift (nope/nil) /fn -\n   yep.ybranch))\n\n(def-type entry k v)\n\n(defn avl-lazy-entries-asc tree\n  (case tree avl-leaf fixops compare\n    (lazy-nil)\n  /case tree avl-branch fixops compare key val branches\n    (cast branches avl-branches nub nbranch yub ybranch\n      err.\\;qq[Expected a branches value of type avl-branches]\n    /lazy-append (c-new avl-lazy-entries-asc nbranch)\n    /lazy-cons (entry key val) /c-new avl-lazy-entries-asc ybranch)\n    err.\\;qq[Expected a tree value of type avl-leaf or avl-branch]))\n\n\\= NOTE: This body takes its args as (state k v).\n(defn avl-any-fold-asc state tree body\n  (lazy-any-foldl state avl-lazy-entries-asc.tree /fn state entry\n    (cast entry entry k v\n      err.\\;qq[Internal error]\n    /c body state k v)))\n\n\\= NOTE: This body takes its args as (state k v).\n(defn avl-any-map-fold-asc state tree body\n  (case tree avl-leaf fixops compare\n    (folding state tree)\n  /case tree avl-branch fixops compare key val branches\n    (cast branches avl-branches nub nbranch yub ybranch\n      err.\\;qq[Expected a branches value of type avl-branches]\n    /caselet first-result\n      (c-new avl-any-map-fold-asc state nbranch body)\n      \n      yep - first-result\n      \n      folding state result-nbranch\n      (caselet second-result (c body state key val)\n        \n        yep - second-result\n        \n        folding state result-val\n        (caselet third-result\n          (c-new avl-any-map-fold-asc state ybranch body)\n          \n          yep - third-result\n          \n          folding state result-ybranch\n          (folding state\n          /avl-branch fixops compare key result-val\n          /avl-branches nub result-nbranch yub result-ybranch)\n          \n          err.\\;qq[Internal error])\n        \n        err.\\;qq[\n          Expected body to return a value of type yep or folding])\n      \n      err.\\;qq[Internal error])\n    err.\\;qq[Expected a tree value of type avl-leaf or avl-branch]))\n\n(defn avl-get-max-depth tree\n  (case tree avl-leaf fixops compare\n    bigint-zero-for-fixops.fixops\n  /case tree avl-branch fixops compare key val branches\n    (cast branches avl-branches nub nbranch yub ybranch\n      err.\\;qq[Expected a branches value of type avl-branches]\n    /let zero bigint-zero-for-fixops.fixops\n    /let one bigint-as-one.zero\n    /bigint-plus one /c-new avl-get-max-depth /case nub nil\n      ybranch\n      nbranch)\n    err.\\;qq[Expected a tree value of type avl-leaf or avl-branch]))\n\n(def-type avl-merge-val a b)\n\n(defn avl-merge a b maybe-process-both\n  \\= TOOD: Make sure this algorithm is near-optimal both when\n  \\= `maybe-process-both` is (yep ...) and when it's (nil). When it's\n  \\= (nil), this algorithm certainly takes at least O( m + n ) time\n  \\= because it transforms every element.\n  \\=\n  \\= Online forum advice for merging AVL trees seems to recommend the\n  \\= use of sorted vectors, building the tree by bisecting the vector.\n  \\= We don't really have bigint-indexable vectors, and bisecting a\n  \\= bigint would have its own time complexity to worry about, so\n  \\= that's not an obvious way forward.\n  \\=\n  \\= (Yes, we're worrying about bigint operation complexity while not\n  \\= worrying about memory allocation complexity.)\n  \n  (let to-left\n    (fn val\n      (case maybe-process-both yep -\n        val\n        (avl-merge-val yep.val (nil))))\n  /let to-right\n    (fn val\n      (case maybe-process-both yep -\n        val\n        (avl-merge-val (nil) yep.val)))\n  /let to-both-keys (fn left right right)\n  /let to-both\n    (fn left right\n      (case maybe-process-both yep process-both\n        (c process-both left right)\n        (avl-merge-val yep.left yep.right)))\n  /let map-left\n    (fn a-branch\n      (case maybe-process-both yep -\n        a-branch\n        (avl-any-map-fold-asc (nil) a-branch /fn state k v\n          (nope/c to-left v))))\n  /let map-right\n    (fn b-branch\n      (case maybe-process-both yep -\n        b-branch\n        (avl-any-map-fold-asc (nil) b-branch /fn state k v\n          (nope/c to-right v))))\n  /let combine-branch-changes\n    (fn wub tub w-balanced-change t-balanced-change\n      w-sub-merge-change t-sub-merge-change\n      \\= TODO: This is one of the few places that actually adds two\n      \\= depth numbers of non-constant size. See if there's an\n      \\= alternative algorithm that avoids this. If there is, we\n      \\= should switch to a unary bigint representation of depth.\n      (case bigint-is-zero.wub yep -\n        (bigint-plus t-balanced-change t-sub-merge-change)\n        (bigint-plus w-balanced-change w-sub-merge-change)))\n  /cast a avl-branch a-fixops a-compare a-key a-val a-branches\n    (let max-depth avl-get-max-depth.b\n    /depth-changed max-depth bigint-as-zero.max-depth /c map-right b)\n  /cast b avl-branch b-fixops b-compare b-key b-val b-branches\n    (let max-depth avl-get-max-depth.a\n    /depth-changed bigint-as-zero.max-depth max-depth /c map-left a)\n  /caselet b-lt-a (c a-compare b-key a-key) nil\n    \n    (cast a-branches avl-branches a-nub a-nbranch a-yub a-ybranch\n      err.\\;qq[Expected an a-branches value of type avl-branches]\n    /cast b-branches avl-branches b-nub b-nbranch b-yub b-ybranch\n      err.\\;qq[Expected a b-branches value of type avl-branches]\n    /cast (c-new avl-merge a-nbranch b-nbranch maybe-process-both)\n      depth-changed an-change bn-change nbranch\n      err.\\;qq[Internal error]\n    /let nub (bigint-plus a-nub an-change)\n    /cast (c-new avl-merge a-ybranch b-ybranch maybe-process-both)\n      depth-changed ay-change by-change ybranch\n      err.\\;qq[Internal error]\n    /let yub (bigint-plus a-yub ay-change)\n    /cast\n      (improper-avl-branch-balance\n      /avl-branch a-fixops a-compare\n        (c to-both-keys a-key b-key)\n        (c to-both a-val b-val)\n      /avl-branches nub nbranch yub ybranch)\n      depth-changed n-change y-change tree\n      err.\\;qq[Internal error]\n    /depth-changed\n      (c combine-branch-changes\n        a-nub a-yub n-change y-change an-change ay-change)\n      (c combine-branch-changes\n        b-nub b-yub n-change y-change bn-change by-change)\n      tree)\n    \n    \\= TODO: See if this case would be more efficient if we sometimes\n    \\= merged `a-wbranch` and `b` instead. We'd probably need to know\n    \\= which of `a` and `b` is smallest, and then merge it with the\n    \\= smallest branch of the other.\n    (cast (avl-branches-swap b-lt-a a-branches)\n      avl-branches a-wub a-wbranch a-tub a-tbranch\n      err.\\;qq[Expected an a-branches value of type avl-branches]\n    /cast (avl-branches-swap b-lt-a b-branches)\n      avl-branches b-wub b-wbranch b-tub b-tbranch\n      err.\\;qq[Expected a b-branches value of type avl-branches]\n    /cast\n      (depth-changed-swap b-lt-a\n      /c-new avl-merge a b-tbranch maybe-process-both)\n      depth-changed a-merge-change b-merge-change tbranch\n      err.\\;qq[Internal error]\n    /let wbranch (c map-right b-wbranch)\n    /let tub (bigint-plus b-tub b-merge-change)\n    /cast\n      (depth-changed-swap b-lt-a\n      /improper-avl-branch-balance\n      /avl-branch b-fixops b-compare b-key (c to-right b-val)\n      /avl-branches-swap b-lt-a\n      /avl-branches b-wub wbranch tub tbranch)\n      depth-changed w-balance-change t-balance-change tree\n      err.\\;qq[Internal error]\n    /depth-changed\n      (bigint-plus t-balance-change a-merge-change)\n      (c combine-branch-changes\n        b-wub b-tub w-balance-change t-balance-change\n        bigint-as-zero.b-merge-change b-merge-change)\n      tree)))\n\n(defn avl-minus-extreme-entry tree k-polarity\n  (case tree avl-leaf fixops compare\n    nope.tree\n  /case tree avl-branch fixops compare key val branches\n    (cast (avl-branches-swap k-polarity branches)\n      avl-branches wub wbranch tub tbranch\n      err.\\;qq[Expected a branches value of type avl-branches]\n    /case (c-new avl-minus-extreme-entry tbranch k-polarity)\n      \n      nope -\n      (avl-minus-extreme-entry-succeeded (yep/nil) key val wbranch)\n      \n      avl-minus-extreme-entry-succeeded\n      max-depth-decreased subtracted-key subtracted-val tbranch\n      (let wub\n        (case max-depth-decreased yep -\n          (bigint-plus wub bigint-as-one.wub)\n          wub)\n      /cast\n        (depth-changed-swap k-polarity\n        /improper-avl-branch-balance\n        /avl-branch fixops compare key val\n        /avl-branches-swap k-polarity\n        /avl-branches wub wbranch tub tbranch)\n        depth-changed w-depth-change t-depth-change balanced-tree\n        err.\\;qq[Internal error]\n      /cast balanced-tree avl-branch - -b -c -d balanced-branches\n        err.\\;qq[Internal error]\n      /cast balanced-branches\n        avl-branches balanced-wub - balanced-tub -b\n        err.\\;qq[Internal error]\n      /avl-minus-extreme-entry-succeeded\n        \n        \\= There are two ways the overall max depth can decrease:\n        \\=\n        \\=  - Subtracting the entry from one side caused that side to\n        \\=    stop having more max depth than the other.\n        \\=  - Subtracting the entry from one side caused that side to\n        \\=    have much less max depth than the other, and the other\n        \\=    lost some depth during a rebalancing.\n        \\=\n        (or\n          (and-lazy (not bigint-is-zero.tub) /fn -\n            bigint-is-zero.balanced-tub)\n          (and-lazy max-depth-decreased /fn -\n          /and-lazy (not bigint-is-zero.wub) /fn -\n            (isa yep /bigint-compare w-depth-change\n              bigint-as-zero.w-depth-change)))\n        \n        subtracted-key subtracted-val balanced-tree)\n      \n      err.\\;qq[Internal error])\n    err.\\;qq[Expected a tree value of type avl-leaf or avl-branch]))\n\n(defn avl-plus-entry tree k v\n  (case tree avl-leaf fixops compare\n    (let zero bigint-zero-for-fixops.fixops\n    /yep/avl-branch fixops compare k v\n    /avl-branches zero tree zero tree)\n  /case tree avl-branch fixops compare key val branches\n    (caselet polarity (c compare key k) nil\n      (nope/avl-branch fixops compare k v branches)\n    /cast (avl-branches-swap polarity branches)\n      avl-branches wub wbranch tub tbranch\n      err.\\;qq[Expected a branches value of type avl-branches]\n    /cast\n      (case (c-new avl-plus-entry tbranch k v)\n        nope result (pair (nope/nil) result)\n        yep result (pair (yep/nil) result)\n        err.\\;qq[Internal error])\n      pair max-depth-increased tbranch\n      err.\\;qq[Internal error]\n    /let new-tub\n      (case max-depth-increased yep -\n        (bigint-plus tub bigint-as-one.tub)\n        tub)\n    /cast\n      (depth-changed-swap polarity\n      /improper-avl-branch-balance\n      /avl-branch fixops compare key val\n      /avl-branches-swap polarity\n      /avl-branches wub wbranch new-tub tbranch)\n      depth-changed w-depth-change t-depth-change balanced-tree\n      err.\\;qq[Internal error]\n    /cast balanced-tree avl-branch - -b -c -d balanced-branches\n      err.\\;qq[Internal error]\n    /cast balanced-branches\n      avl-branches balanced-wub - balanced-tub -b\n      err.\\;qq[Internal error]\n    /yep-nope-swap\n      \n      \\= There are two ways the overall max depth can increase:\n      \\=\n      \\=  - Adding the entry to one side caused that side to start\n      \\=    having more max depth than the other.\n      \\=  - Adding the entry to one side caused that side to have much\n      \\=    more max depth than the other, and it didn't lose that\n      \\=    edge during a rebalancing.\n      \\=\n      (or\n        (and-lazy bigint-is-zero.tub /fn -\n        /not bigint-is-zero.balanced-tub)\n        (and-lazy max-depth-increased /fn -\n        /and-lazy (not bigint-is-zero.tub) /fn -\n          (not/isa yep /bigint-compare t-depth-change\n            bigint-as-zero.t-depth-change)))\n      yep.balanced-tree)\n    err.\\;qq[Expected a tree value of type avl-leaf or avl-branch]))\n\n(defn avl-minus-entry tree k\n  (case tree avl-leaf fixops compare\n    nope.tree\n  /case tree avl-branch fixops compare key val branches\n    (caselet polarity (c compare key k) nil\n      (avl-branch-finish-minus fixops compare branches)\n    /cast (avl-branches-swap polarity branches)\n      avl-branches wub wbranch tub tbranch\n      err.\\;qq[Expected a branches value of type avl-branches]\n    /cast\n      (case (c-new avl-minus-entry tbranch k)\n        nope result (pair (nope/nil) result)\n        yep result (pair (yep/nil) result)\n        err.\\;qq[Internal error])\n      pair max-depth-decreased tbranch\n      err.\\;qq[Internal error]\n    /let new-wub\n      (case max-depth-decreased yep -\n        (bigint-plus tub bigint-as-one.tub)\n        tub)\n    /cast\n      (depth-changed-swap polarity\n      /improper-avl-branch-balance\n      /avl-branch fixops compare key val\n      /avl-branches-swap polarity\n      /avl-branches new-wub wbranch tub tbranch)\n      depth-changed w-depth-change t-depth-change balanced-tree\n      err.\\;qq[Internal error]\n    /cast balanced-tree avl-branch - -b -c -d balanced-branches\n      err.\\;qq[Internal error]\n    /cast balanced-branches\n      avl-branches balanced-wub - balanced-tub -b\n      err.\\;qq[Internal error]\n    /yep-nope-swap\n      \n      \\= There are two ways the overall max depth can decrease:\n      \\=\n      \\=  - Subtracting the entry from one side caused that side to\n      \\=    stop having more max depth than the other.\n      \\=  - Subtracting the entry from one side caused that side to\n      \\=    have much less max depth than the other, and the other\n      \\=    lost some depth during a rebalancing.\n      \\=\n      (or\n        (and-lazy (not bigint-is-zero.tub) /fn -\n          bigint-is-zero.balanced-tub)\n        (and-lazy max-depth-decreased /fn -\n        /and-lazy (not bigint-is-zero.wub) /fn -\n          (isa yep /bigint-compare w-depth-change\n            bigint-as-zero.w-depth-change)))\n      yep.balanced-tree)\n    err.\\;qq[Expected a tree value of type avl-leaf or avl-branch]))\n\n(defn avl-has-any tree\n  (not/isa avl-leaf tree))\n\n\\= TODO: Rename this to be more convenient to call.\n(defn avl-minus-entry-ignoring-depth avl k\n  (case (avl-minus-entry avl k)\n    yep result result\n    nope result result\n    err.\\;qq[Internal error]))\n\n\\= TODO: Rename this to be more convenient to call.\n(defn avl-plus-entry-ignoring-depth avl k\n  (case (avl-plus-entry avl k)\n    yep result result\n    nope result result\n    err.\\;qq[Internal error]))\n\n(defn avl-plus-nil tree k\n  (avl-plus-entry tree k /nil))\n\n(defn avl-plus-nils tree list\n  (foldl tree list /avl-plus-nil))\n\n\\= NOTE: This check takes its args as (k v).\n(defn avl-any tree check\n  (caselet result\n    (avl-any-fold-asc (nil) tree /fn state k v /c check k v)\n    nope - (nope/nil)\n    result))\n\n\\= NOTE: This check takes its args as (k v).\n(defn avl-all tree check\n  (not/avl-any tree /fn k v\n    (not/c check k v)))\n\n\\= NOTE: This body takes its args as (k v).\n(defn avl-each tree body\n  (let -\n    (avl-any tree /fn k v\n      (let - (c body k v)\n      /nope/nil))\n  /nil))\n\n\\= NOTE: This body takes its args as (state k v).\n(defn avl-fold-asc state tree body\n  (proj1 nope /avl-any-fold-asc state tree /fn state k v\n    (nope/c body state k v)))\n\n\\= NOTE: This body takes its args as (k v).\n(defn avl-map tree body\n  (case\n    (avl-any-map-fold-asc (nil) tree /fn state k v\n      (folding (nil) /c body k v))\n    folding state result result\n    err.\\;qq[Internal error]))\n\n(defn avl-plus a b\n  (cast (avl-merge a b /yep/fn a b b)\n    depth-changed n-depth-change y-depth-change tree\n    err.\\;qq[Internal error]\n    tree))\n\n\n\\= ===== Finger trees ================================================\n\n\\= NOTE: Finger trees don't have their best amortized computational\n\\= complexity unless they can use lazy thunks, so they're not like the\n\\= other, stateless utilities here.\n\n\\= The `ftree-meta` value's `make-lazy` and `force` should usually\n\\= implement memoized thunks. However, they may also implement pure\n\\= thunks that execute more than once. This finger tree implementation\n\\= will only ever call them with thunks that are safe to execute more\n\\= than once, and which have the same space footprint before and after\n\\= the computation.\n\\=\n\\= When `make-lazy` implements memoized thunks, the `ftree-push` and\n\\= `ftree-pop` operations run in amortized constant time, and the\n\\= `ftree-get-summary-stack` and `ftree-split` operations run in\n\\= logarithmic time. (TODO: Is that true?)\n\\=\n\\= When it implements pure thunks, all four of these operations run in\n\\= logarithmic time. (TODO: Is that true?)\n\n(defn make-immediate-lazy make-lazy val\n  (c make-lazy /fn - val))\n\n(defn list-order-swap polarity list\n  (case polarity yep - list rev.list))\n\n(def-type ftree-meta make-lazy force measure plus)\n(def-type ftree-node summary elements)\n\n\\= NOTE: The values of `n-digits` and `y-digits` are lists of one to\n\\= four elements. When used directly in an `ftree-deep`, the elements\n\\= in `n-digits` are the first ones, and the keys in `y-digits` are\n\\= the last ones.\n(def-type ftree-digits n-digits y-digits)\n\n(def-type ftree-empty meta)\n(def-type ftree-single meta element)\n\n\\= NOTE: The value of `lazy-next` is a `make-lazy` object that\n\\= calculates a finger tree containing \"nodes\" containing the type of\n\\= elements of this finger tree. A node is an object of the form\n\\= (ftree-node summary elements), where `elements` is a list of two or\n\\= three elements.\n(def-type ftree-deep meta digits lazy-next)\n\n(defn ftree-digits-swap polarity digits\n  (case polarity yep - digits\n  /cast digits ftree-digits n-digits y-digits\n    err.\\;qq[Expected a digits value of type ftree-digits]\n  /ftree-digits y-digits n-digits))\n\n(defn ftree-push tree polarity new-element\n  (case tree ftree-empty meta\n    (ftree-single meta new-element)\n  /case tree ftree-single meta element\n    (cast meta ftree-meta make-lazy force measure plus\n      err.\\;qq[Expected a meta value of type ftree-meta]\n    /let sub-measure\n      (fn node\n        (cast node ftree-node summary elements\n          err.\\;qq[Expected a node value of type ftree-node]\n          summary))\n    /ftree-deep meta\n      (ftree-digits-swap polarity\n      /ftree-digits (cons element /nil) (cons new-element /nil))\n    /make-immediate-lazy make-lazy\n    /ftree-empty/ftree-meta make-lazy force sub-measure plus)\n  /case tree ftree-deep meta digits lazy-next\n    (cast meta ftree-meta make-lazy force measure plus\n      err.\\;qq[Expected a meta value of type ftree-meta]\n    /cast (ftree-digits-swap polarity digits)\n      ftree-digits w-digits t-digits\n      err.\\;qq[Expected a digits value of type ftree-digits]\n    /let not-four-digits\n      (fn -\n        (ftree-deep meta\n          (ftree-digits-swap polarity\n          /ftree-digits w-digits\n            (append t-digits /cons new-element /nil))\n          lazy-next))\n    /cast t-digits cons d0 t-digits (c not-four-digits /nil)\n    /cast t-digits cons d1 t-digits (c not-four-digits /nil)\n    /cast t-digits cons d2 t-digits (c not-four-digits /nil)\n    /cast t-digits cons d3 t-digits (c not-four-digits /nil)\n    /let d012 (cons d0 /cons d1 /cons d2 /nil)\n    /let new-node (ftree-node (c plus /map d012 measure) d012)\n    /ftree-deep meta\n      (ftree-digits-swap polarity\n      /ftree-digits w-digits (cons d3 /cons new-element /nil))\n    \\= NOTE: This `makeLazy()` isn't constant-time, so it's impure. It\n    \\= does have the same space footprint before and after.\n    /c make-lazy /fn -\n      (c-new ftree-push (c force lazy-next) polarity new-node))\n    err.\\;qq[\n      Expected a tree value of type ftree-empty, ftree-single, or\n      ftree-deep]))\n\n\\= NOTE: If the `polarity` is `(nope/nil)`, this will push the\n\\= elements so they're in the opposite order as they are in the\n\\= original list.\n(defn ftree-push-list tree polarity list\n  (foldl tree list /fn tree elem /ftree-push tree polarity elem))\n\n(def-type ftree-pop-result maybe-popped-val tree)\n\n(defn ftree-pop tree polarity\n  (case tree ftree-empty meta\n    (ftree-pop-result (nil) tree)\n  /case tree ftree-single meta element\n    (ftree-pop-result yep.element ftree-empty.meta)\n  /case tree ftree-deep meta digits lazy-next\n    (cast (ftree-digits-swap polarity digits)\n      ftree-digits w-digits t-digits\n      err.\\;qq[Expected a digits value of type ftree-digits]\n    /cast rev.t-digits cons last rev-past\n      err.\\;qq[Expected a t-digits value with at least one digit]\n    /ftree-pop-result yep.last\n    /c-new ftree-maybe-deep polarity meta\n      (ftree-digits-swap polarity /ftree-digits w-digits rev.rev-past)\n      lazy-next)\n    err.\\;qq[\n      Expected a tree value of type ftree-empty, ftree-single, or\n      ftree-deep]))\n\n(defn ftree-get-summary-stack tree\n  (case tree ftree-empty meta\n    (cast meta ftree-meta make-lazy force measure plus\n      err.\\;qq[Expected a meta value of type ftree-meta]\n    /cons (c plus /nil) /nil)\n  /case tree ftree-single meta element\n    (cast meta ftree-meta make-lazy force measure plus\n      err.\\;qq[Expected a meta value of type ftree-meta]\n    /cons (c measure element) /nil)\n  /case tree ftree-deep meta digits lazy-next\n    (cast meta ftree-meta make-lazy force measure plus\n      err.\\;qq[Expected a meta value of type ftree-meta]\n    /let add-side\n      (fn summary polarity\n        (cast (ftree-digits-swap polarity digits)\n          ftree-digits w-digits t-digits\n          err.\\;qq[Expected a digits value of type ftree-digits]\n        /foldl summary t-digits /fn summary digit\n          (c plus /list-order-swap polarity\n          /cons summary /cons (c measure digit) /nil)))\n    /let parent-summary-stack\n      (c-new ftree-get-summary-stack /c force lazy-next)\n    /cast parent-summary-stack cons summary rest\n      err.\\;qq[Internal error]\n    /let summary (c add-side summary /nope/nil)\n    /let summary (c add-side summary /yep/nil)\n    /cons summary parent-summary-stack)\n    err.\\;qq[\n      Expected a tree value of type ftree-empty, ftree-single, or\n      ftree-deep]))\n\n\\= This works like `(ftree-deep meta digits lazy-next)`, except that\n\\= it allows one of the sides of digits to be empty.\n(defn ftree-maybe-deep polarity meta digits lazy-next\n  (cast meta ftree-meta make-lazy force measure plus\n    err.\\;qq[Expected a meta value of type ftree-meta]\n  /cast (ftree-digits-swap polarity digits)\n    ftree-digits w-digits t-digits\n    err.\\;qq[Expected a digits value of type ftree-digits]\n  /case t-digits cons - -b (ftree-deep meta digits lazy-next)\n  /cast (ftree-pop (c force lazy-next) polarity)\n    ftree-pop-result maybe-node rest\n    err.\\;qq[Internal error]\n  /cast maybe-node yep node\n    (ftree-push-list ftree-empty.meta not.polarity w-digits)\n  /cast node ftree-node summary elements\n    err.\\;qq[\n      Expected the finger tree in lazy-next to contain values of type\n      ftree-node]\n  /ftree-deep meta\n    (ftree-digits-swap polarity\n    /ftree-digits w-digits (list-order-swap polarity elements))\n  /make-immediate-lazy make-lazy rest))\n\n(def-type ftree-split-iter-state summary-so-far rev-before after)\n(def-type ftree-split-iter-result-fell-off summary-so-far)\n(def-type ftree-split-iter-result-completed early-tree late-tree)\n\n(defn ftree-split-iter\n  tree summary-so-far summary-stack polarity test-is-early\n  \n  (case tree ftree-empty meta\n    ftree-split-iter-result-fell-off.summary-so-far\n  /case tree ftree-single meta element\n    (cast meta ftree-meta make-lazy force measure plus\n      err.\\;qq[Expected a meta value of type ftree-meta]\n    /let summary-so-far\n      (c plus /list-order-swap polarity\n      /cons (c measure element) /cons summary-so-far /nil)\n    /case (c test-is-early summary-so-far) yep -\n      ftree-split-iter-result-fell-off.summary-so-far\n    /ftree-split-iter-result-completed ftree-empty.meta tree)\n  /case tree ftree-deep meta digits lazy-next\n    (cast meta ftree-meta make-lazy force measure plus\n      err.\\;qq[Expected a meta value of type ftree-meta]\n    /cast summary-stack cons summary-stack-first summary-stack-rest\n      err.\\;qq[Expected a summary-stack value of type cons]\n    /cast (ftree-digits-swap polarity digits)\n      ftree-digits w-digits t-digits\n      err.\\;qq[Expected a digits value of type ftree-digits]\n    /let try-side\n      (fn summary-so-far side-polarity on-failed\n        (let iterating-inward (not/xor polarity side-polarity)\n        /cast (ftree-digits-swap polarity digits)\n          ftree-digits w2-digits t2-digits\n          err.\\;qq[Internal error]\n        /let digits-to-traverse\n          (list-order-swap iterating-inward rev.t2-digits)\n        /case\n          (any-foldl\n            (ftree-split-iter-state summary-so-far (nil)\n              digits-to-traverse)\n            digits-to-traverse\n          /fn state elem\n            (cast state\n              ftree-split-iter-state summary-so-far rev-before after\n              err.\\;qq[Internal error]\n            /cast after cons elem after\n              err.\\;qq[Internal error]\n            /let summary-so-far\n              (c plus /list-order-swap polarity\n              /cons (c measure elem) /cons summary-so-far /nil)\n            /case (c test-is-early summary-so-far) yep -\n              (nope/ftree-split-iter-state\n                summary-so-far (cons elem rev-before) after)\n              yep.state))\n          \n          yep state\n          (cast state\n            ftree-split-iter-state summary-so-far rev-before after\n            err.\\;qq[Internal error]\n          /c on-failed summary-so-far)\n          \n          nope state\n          (cast state\n            ftree-split-iter-state summary-so-far rev-before after\n            err.\\;qq[Internal error]\n          /let w2t-digits\n            (case iterating-inward yep -\n              rev.after\n              rev.rev-before)\n          /let t2-digits\n            (case iterating-inward yep -\n              rev-before\n              after)\n          /let t2-tree\n            (ftree-push-list ftree-empty.meta side-polarity t2-digits)\n          /let w2-tree\n            (ftree-maybe-deep side-polarity meta\n              (ftree-digits-swap side-polarity\n              /ftree-digits w2-digits w2t-digits)\n              lazy-next)\n          /case iterating-inward yep -\n            (ftree-split-iter-result-completed t2-tree w2-tree)\n            (ftree-split-iter-result-completed w2-tree t2-tree))\n          \n          err.\\;qq[Internal error]))\n    \n    \\= Try each of the `polarity`-side digits.\n    /c try-side summary-so-far polarity /fn summary-so-far\n    \n    \\= Try a recursive call on the `lazy-next`.\n    /case\n      (c-new ftree-split-iter (c force lazy-next) summary-so-far\n        summary-stack-rest polarity test-is-early)\n      \n      ftree-split-iter-result-completed early-tree late-tree\n      (ftree-split-iter-result-completed\n        (ftree-push-list early-tree polarity t-digits)\n        (ftree-push-list late-tree not.polarity w-digits))\n      \n      ftree-split-iter-result-fell-off summary-so-far\n      \\= Try each of the digits on the side opposite to `polarity`.\n      (c try-side summary-so-far not.polarity\n      /fn summary-so-far\n      /ftree-split-iter-result-fell-off summary-so-far)\n      \n      err.\\;qq[Internal error])\n    \n    err.\\;qq[\n      Expected a tree value of type ftree-empty, ftree-single, or\n      ftree-deep]))\n\n(defn ftree-append-with-middle a middle b\n  (case a ftree-empty meta\n    (ftree-push-list b (nope/nil) rev.middle)\n  /case b ftree-empty meta\n    (ftree-push-list a (yep/nil) middle)\n  /case a ftree-single meta element\n    (ftree-push-list b (nope/nil)\n    /rev-append middle /cons element /nil)\n  /case b ftree-single meta element\n    (ftree-push-list a (yep/nil)\n    /append middle /cons element /nil)\n  /cast a ftree-deep a-meta a-digits a-lazy-next\n    err.\\;qq[\n      Expected an a value of type ftree-empty, ftree-single, or\n      ftree-deep]\n  /cast a-digits ftree-digits an-digits ay-digits\n    err.\\;qq[Expected an a-digits value of type ftree-digits]\n  /cast b ftree-deep b-meta b-digits b-lazy-next\n    err.\\;qq[\n      Expected a b value of type ftree-empty, ftree-single, or\n      ftree-deep]\n  /cast b-digits ftree-digits bn-digits by-digits\n    err.\\;qq[Expected a b-digits value of type ftree-digits]\n  /cast a-meta ftree-meta make-lazy force measure plus\n    err.\\;qq[Expected an a-meta value of type ftree-meta]\n  /ftree-deep a-meta (ftree-digits an-digits by-digits)\n  \\= NOTE: This `make-lazy` isn't constant-time, so it's impure. It\n  \\= does have the same space footprint before and after.\n  /c make-lazy /c-new ftree-append-with-middle\n    (c force a-lazy-next)\n    (append ay-digits /append middle bn-digits)\n    (c force b-lazy-next)))\n\n(def-type ftree-split-result early-tree late-tree)\n\n\\= This looks through every segment of the tree starting from the end\n\\= that corresponds with `polarity` until it can drill down to the one\n\\= element whose summary doesn't satisfy the predicate\n\\= `test-is-early`. It returns\n\\= `(ftree-split-result early-tree late-tree)` with a tree containing\n\\= the early elements and a tree containing the rest. (Note that if\n\\= the polarity is 1, the `earlyTree` will be a suffix of the original\n\\= tree, and `lateTree` will be a prefix.)\n\\=\n\\= The `test-is-early` function is expected to satisfy certain\n\\= properties with regard to the measurement monoid:\n\\=\n\\=   early (a + b) -> early a\n\\=   early 0\n\\=\n\\= This allows us to scan over aggregate summaries (the `summary`\n\\= property of `(ftree-node summary elements)` node values) and\n\\= determine they're fully early without having to drill down and scan\n\\= them for exceptional prefixes.\n\\=\n\\= NOTE: This operation doesn't follow quite the same contract as\n\\= Hinze and Paterson's `splitTree`. In particular, where we use\n\\= `test-is-early`, they use the complement of that predicate, and\n\\= where we split the tree into two trees, they split it into two\n\\= trees and a first non-early element in between, which their\n\\= operation requires to exist.\n\\=\n(defn ftree-split tree polarity test-is-early\n  (let meta\n    (case tree ftree-empty meta meta\n    /case tree ftree-single meta element meta\n    /case tree ftree-deep meta digits lazy-next meta\n      err.\\;qq[\n        Expected a tree value of type ftree-empty, ftree-single, or\n        ftree-deep])\n  /cast meta ftree-meta make-lazy force measure plus\n    err.\\;qq[Expected a meta value of type ftree-meta]\n  /case\n    (ftree-split-iter (c plus /nil)\n      ftree-get-summary-stack.tree polarity test-is-early)\n    \n    ftree-split-iter-result-fell-off summary-so-far\n    \\= Apparently everything is early.\n    (ftree-split-result tree ftree-empty.meta)\n    \n    ftree-split-iter-result-completed early-tree late-tree\n    (ftree-split-result early-tree late-tree)\n    \n    err.\\;qq[Internal error]))\n\n\n\\= ===== Big finger trees ============================================\n\\=\n\\= A native platform (namely, JavaScript) may provide an efficient\n\\= finger-tree-like data structure with the exception that the size of\n\\= the data is limited. These \"big finger trees\" are finger trees\n\\= implemented as finger trees whose elements abstractly follow a\n\\= finger-tree-style interface, with the anomaly that the elements'\n\\= concatenation operation doesn't have to be total.\n\n(def-type fix-ftree-ops push pop maybe-plus split)\n(def-type bftree fix-ftree-ops ftree)\n\n(defn ftree-is-too-empty-to-pop elem pop\n  (cast (c pop elem /yep/nil) ftree-pop-result maybe-popped -\n    err.\\;qq[Expected pop to return a value of type ftree-pop-result]\n  /isa nil maybe-popped))\n\n(defn bftree-push tree polarity elem\n  (cast tree bftree fix-ftree-ops ftree\n    err.\\;qq[Expected a tree value of type bftree]\n  /cast fix-ftree-ops fix-ftree-ops push pop maybe-plus split\n    err.\\;qq[Expected a fix-ftree-ops value of type fix-ftree-ops]\n  /case (ftree-is-too-empty-to-pop elem pop) yep - tree\n  /cast (ftree-pop ftree polarity)\n    ftree-pop-result maybe-popped diminished-ftree\n    err.\\;qq[Internal error]\n  /bftree fix-ftree-ops\n  /case\n    (cast maybe-popped yep popped (nil)\n    /case polarity yep -\n      (c maybe-plus popped elem)\n      (c maybe-plus elem popped))\n    yep elem (ftree-push diminished-ftree polarity elem)\n    (ftree-push ftree polarity elem)))\n\n(defn bftree-pop tree polarity\n  (cast tree bftree fix-ftree-ops ftree\n    err.\\;qq[Expected a tree value of type bftree]\n  /cast fix-ftree-ops fix-ftree-ops push pop maybe-plus split\n    err.\\;qq[Expected a fix-ftree-ops value of type fix-ftree-ops]\n  /cast (ftree-pop ftree polarity) ftree-pop-result maybe-popped ftree\n    err.\\;qq[Internal error]\n  /cast maybe-popped yep popped\n    (ftree-pop-result (nil) ftree)\n  /cast (c pop popped polarity) ftree-pop-result maybe-popped new-leaf\n    err.\\;qq[\n      Expected a fix-ftree-ops's pop function to return a value of\n      type ftree-pop-result]\n  /cast maybe-popped yep popped\n    err.\\;qq[\n      Expected a bftree's ftree to contain only nonempty leaves]\n  /ftree-pop-result maybe-popped\n  /bftree fix-ftree-ops /ftree-push ftree polarity new-leaf))\n\n(defn bftree-plus a b\n  (cast a bftree fix-ftree-ops a\n    err.\\;qq[Expected an a value of type bftree]\n  /cast b bftree - b\n    err.\\;qq[Expected a b value of type bftree]\n  /cast fix-ftree-ops fix-ftree-ops push pop maybe-plus split\n    err.\\;qq[Expected a fix-ftree-ops value of type fix-ftree-ops]\n  /cast (ftree-pop a /yep/nil)\n    ftree-pop-result a-maybe-popped a-diminished\n    err.\\;qq[Internal error]\n  /cast (ftree-pop b /yep/nil)\n    ftree-pop-result b-maybe-popped b-diminished\n    err.\\;qq[Internal error]\n  /bftree fix-ftree-ops\n  /cast a-maybe-popped yep a-elem (ftree-append-with-middle a (nil) b)\n  /cast b-maybe-popped yep b-elem (ftree-append-with-middle a (nil) b)\n  /cast (c maybe-plus a-elem b-elem) yep elem\n    (ftree-append-with-middle a (nil) b)\n  /ftree-append-with-middle\n    a-diminished (cons elem /nil) b-diminished))\n\n(defn bftree-split tree polarity test-is-early\n  (cast tree bftree fix-ftree-ops ftree\n    err.\\;qq[Expected a tree value of type bftree]\n  /cast fix-ftree-ops fix-ftree-ops push pop maybe-plus split\n    err.\\;qq[Expected a fix-ftree-ops value of type fix-ftree-ops]\n  /cast (ftree-split ftree polarity test-is-early)\n    ftree-split-result early-tree late-tree\n    err.\\;qq[Internal error]\n  /cast (ftree-pop late-tree polarity)\n    ftree-pop-result maybe-popped late-tree\n    err.\\;qq[Internal error]\n  /cast maybe-popped yep popped\n    (ftree-split-result\n      (bftree fix-ftree-ops early-tree)\n      (bftree fix-ftree-ops late-tree))\n  /cast (c split popped polarity test-is-early)\n    ftree-split-result early-elem late-elem\n    err.\\;qq[Internal error]\n  /ftree-split-result\n    (bftree fix-ftree-ops\n    /ftree-push early-tree not.polarity early-elem)\n    (bftree fix-ftree-ops /ftree-push late-tree polarity late-elem)))\n\n\n\\= ===== Comparison utilities ========================================\n\n(def-type comparable compare val)\n\n(defn comparable-compare a b\n  (cast a comparable compare a-val\n    err.\\;qq[Expected an a value of type comparable]\n  /cast b comparable - b-val\n    err.\\;qq[Expected a b value of type comparable]\n  /c compare a-val b-val))\n\n\\= With the following utilities `bimap` and `cmpd-compare`, we can\n\\= more easily define ordered abstract data types. For instance:\n\\= -----\n\\;rm(\n  (def-type foo x y)\n  (def-type bar x)\n  (def-type baz)\n  \n  (defn foo-bar-baz-compare a b\n    (bimap (cmpd-compare) a b /fn it\n      (case it foo x y\n        (cmpd-cons (bigint-compare) x\n        /cmpd-cons (bigint-compare) y\n        /cmpd-nil)\n      /cmpd-succ/case it bar x\n        (cmpd-cons (bigint-compare) x /cmpd-nil)\n      /cmpd-succ/case it baz (cmpd-nil)\n        err.\\;qq[Expected a value of type foo, bar, or baz])))\n)\n\\= -----\n\n(defn bimap combine a b func\n  (c combine (c func a) (c func b)))\n\n\\= NOTE: The \"cmpd\" stands for \"comparison delegate.\"\n(def-type cmpd-succ rest)\n(def-type cmpd-cons compare val rest)\n(def-type cmpd-nil)\n\n(defn cmpd-compare a b\n  (case a cmpd-succ a-rest\n    (case b cmpd-succ b-rest\n      (c-new cmpd-compare a-rest b-rest)\n      (nope/nil))\n  /case b cmpd-succ b-rest (yep/nil)\n  /case a cmpd-cons compare a-val a-rest\n    (case b cmpd-cons - b-val b-rest\n      (caselet comparison (c compare a-val b-val) nil\n        (c-new compare a-rest b-rest)\n        comparison)\n      err.\\;qq[\n        Expected a and b to be the same length since neither was a\n        cmpd-succ])\n  /case b cmpd-cons compare b-val b-rest\n    err.\\;qq[\n      Expected a and b to be the same length since neither was a\n      cmpd-succ]\n  /cast a cmpd-nil\n    err.\\;qq[\n      Expected an a value of type cmpd-succ, cmpd-cons, or cmpd-nil]\n  /cast b cmpd-nil\n    err.\\;qq[\n      Expected a b value of type cmpd-succ, cmpd-cons, or cmpd-nil]\n  /nil))\n\n\n\\= ===== Recommended settings for performance ========================\n\n(defn make-fixops-recommended -\n  (make-fixops-yep-nope/nil))\n\n(defn bigint-zero-recommended -\n  (bigint-zero-for-fixops/make-fixops-recommended/nil))\n\n\n\\= ===== Sets (bags) =================================================\n\n(def-type bag avl-tree)\n\n(defn bag-all bag check\n  (cast bag bag avl-tree\n    err.\\;qq[Expected a bag value of type bag]\n  /avl-all avl-tree /fn k v\n    (c check k)))\n\n(defn bag-empty compare\n  (bag/avl-leaf (make-fixops-recommended/nil) compare))\n\n(defn bag-plus a b\n  (cast a bag a-avl-tree\n    err.\\;qq[Expected an a value of type bag]\n  /cast b bag b-avl-tree\n    err.\\;qq[Expected a b value of type bag]\n  /bag/avl-plus a-avl-tree b-avl-tree))\n\n(defn bag-any-fold-asc state bag body\n  (cast bag bag avl-tree\n    err.\\;qq[Expected a bag value of type bag]\n  /avl-any-fold-asc state avl-tree /fn state k v\n    (c body state k)))\n\n(defn bag-fold-asc state bag body\n  (proj1 nope /bag-any-fold-asc state bag /fn state elem\n    (nope/c body state elem)))\n\n(defn bag-mappend compare bag func\n  (bag-fold-asc bag-empty.compare bag /fn state elem\n    (bag-plus state /c func elem)))\n\n(defn bag-minus a b\n  (cast a bag a-avl-tree\n    err.\\;qq[Expected an a value of type bag]\n  /cast b bag b-avl-tree\n    err.\\;qq[Expected a b value of type bag]\n  /bag/bag-fold-asc a-avl-tree b /fn state elem\n    (avl-minus-entry state elem)))\n\n(defn bag-only bag\n  (case\n    (bag-any-fold-asc (nil) bag /fn state elem\n      (case state yep -\n        (yep/nil)\n        (nope yep.elem)))\n    nope val val\n  /nil))\n\n(defn bag-plus-elem bag elem\n  (cast bag bag avl-tree\n    err.\\;qq[Expected a bag value of type bag]\n  /bag/avl-plus-nil avl-tree elem))\n\n(defn bag-compare a b\n  (let compare avl-comparer.a\n  /lazy-list-compare-by avl-lazy-entries-asc.a avl-lazy-entries-asc.b\n  /fn a b\n    (bimap compare a b /fn it\n      (cast it entry k v\n        err.\\;qq[Internal error]\n        k))))\n\n(defn bag-just compare elem\n  (bag-plus-elem bag-empty.compare elem))\n\n(defn bag-map compare bag func\n  (bag-mappend compare bag /fn elem\n    (bag-just compare /c func elem)))\n\n\n\\= ===== Lenses ======================================================\n\n(def-type lens get replace)\n\n(defn lens-get lens\n  (cast lens lens get replace\n    err.\\;qq[Expected a lens value of type lens]\n  /c get /nil))\n\n(defn lens-replace lens val\n  (cast lens lens get replace\n    err.\\;qq[Expected a lens value of type lens]\n  /c replace val))\n\n(defn lens-replace-by lens func\n  (cast lens lens get replace\n    err.\\;qq[Expected a lens value of type lens]\n  /c replace /c func /c get /nil))\n";
