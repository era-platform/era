"use strict";
var rocketnia = rocketnia || {};
rocketnia.eraFiles = rocketnia.eraFiles || {};
rocketnia.eraFiles[ "era-staccato-self-compiler.stc" ] =
"\\= era-staccato-self-compiler.stc\n\\= Copyright 2015, 2016 Ross Angle. Released under the MIT License.\n\n\n\\= Although this may look like source code, and it may even become\n\\= full source code at some point, right now it mostly serves as a\n\\= collection of notes.\n\\=\n\\= One side of the notes explores a potential high-level design for\n\\= Staccato macro definitions and ad hoc namespace manipulation. This\n\\= is far more expressive than Staccato is likely to support for some\n\\= time, but it means that I can begin writing Staccato code freely,\n\\= safe in the knowledge that I won't be tied down to regretful name\n\\= choices or ever-growing lists of syntactic primitives.\n\\=\n\\= The other side of these notes begins the more immediate exercise of\n\\= porting the era-stacato.js desugarer to Staccato. This could\n\\= hypothetically be used to implement `(defn ...)` and\n\\= `(def-type ...)` as macros someday, but what it ensures is that the\n\\= design of the desugarer itself is something programmers can replace\n\\= when needed. Furthermore, the port should ultimately support a\n\\= slightly different syntax than before: In a raw Staccato AST,\n\\= constructors and their projections will no longer be designated by\n\\= unqualified strings, but by fully qualified names.\n\n\n\\= ===== Notes about dependencies ====================================\n\n\\= (def-type string val)\n\\= A reference to a string. The value inside is in a format user-level\n\\= code does not know how to deconstruct.\n\n\\= (defn string-compare a b ...)\n\\= Compares two strings.\n\n\\= macro (str \\;qq[example string])\n\\= Obtains a first-class string value with the given literal text.\n\n\\= (def-type name val)\n\\= A reference to a fully qualified name. The value inside is in a\n\\= format user-level code does not know how to deconstruct.\n\n\\= (defn make-tuple-tag tuple-name proj-names)\n\\= Takes a name for the constructor and a list of names for the\n\\= projections, and returns the name used to dynamically tag a tuple\n\\= of that combination of names. The projection name list must be made\n\\= out of `(cons car cdr)` and `(nil)` values, with elements that are\n\\= strings, and the list must not have duplicates. The order of the\n\\= list will be ignored.\n\n\\= (defn name-metacompare a b ...)\n\\= Compares two names. For inequal names, the result will be in a\n\\= format user-level code does not know how to deconstruct. For equal\n\\= names, the result will be (nil).\n\\=\n\\= Names are somewhat useful for access control, and they're opaque\n\\= external tokens to an extent, but they're not entirely opaque. They\n\\= can be compared for equality.\n\\=\n\\= Macros would be less expressive if they had to treat names as\n\\= uncomparable values, and what benefit would that bring? The macros\n\\= would still have a range of expression close to that anyway: A\n\\= macro could still dive into one of its syntax parameters and\n\\= extract names from there into its own bag of tricks, so names\n\\= wouldn't really be secrets between macros. A macro could still\n\\= reconstruct a syntax parameter while inserting two occurrences of\n\\= any name it likes, just to ensure that the two occurrences are\n\\= equal. A macro could still do a hackish equality assertion by\n\\= defining something by one name and looking up the definition by\n\\= another. A macro could still do a hackish *inequality* assertion by\n\\= installing two definitions under the (supposedly) two names.\n\\=\n\\= If macros couldn't check names for equality, one thing a macro\n\\= couldn't do... is to associate a variable binding site with a\n\\= variable usage site. For instance, it couldn't act as a Staccato\n\\= desugarer. It couldn't act as a compiler of some other DSL, unless\n\\= that DSL completely forewent the namespace system and just used\n\\= string names everywhere. So people who have adventurous new\n\\= syntaxes to try would want to build new namespace systems for them,\n\\= and this macro system would have complicated the Staccato language\n\\= for no purpose that couldn't have been accomplished with an\n\\= exhaustive suite of built-in syntaxes.\n\\=\n\\= (TODO: Do nominal types already support an equality check?\n\\= James Cheney's \"Simple Nominal Type Theory\" presents systems with\n\\= and without equality checks. If this is very common, maybe we can\n\\= rationalize this decision in terms of standard practice too.)\n\\=\n\\= So, macros will be able to compare names for equality. As long as\n\\= they can do that, we could promote better efficiency by permitting\n\\= ordered comparisons instead of just equality checks. That way,\n\\= names could be lookup keys in AVL trees and other efficiently\n\\= indexed data structures.\n\\=\n\\= It's tricky, because names have no natural ordering. Even if they\n\\= were arbitrarily associated with strings and ordered that way, that\n\\= ordering would not be stable in the face of capture-avoiding\n\\= alpha-renaming! So whatever order we use, it will expose\n\\= implementation details and make namespace sandboxing into a\n\\= headache... unless, that is, the implementation details were hidden\n\\= in a familiar way: By using obscure naming (and enforcing this\n\\= obscurity with code-signing if necessary).\n\\=\n\\= To wit, we can refrain from exposing implementation details by\n\\= defining \"metacompare\" operations that usually work like \"compare\"\n\\= operations, but sometimes return values that user-defined macro\n\\= code doesn't know how to deconstruct. (The \"meta\" stands for\n\\= \"metacircular\", under the idea that there may be a few layers of\n\\= the reflective tower all running as macros in the same\n\\= macroexpansion phase. Each layer must be implemented with obscure\n\\= names that its interpreted layer doesn't know about.) Once we have\n\\= metacomparison operations, we can provide encapsulated data types\n\\= that sort their data using a metacomparison.\n\\=\n\\= If we just support encapsulated AVL trees, that might go a long\n\\= way, especially if it serves as a complete model of computation\n\\= over unordered collections. We can get quite a range of\n\\= computational ability all at once if we simply add a metacomparator\n\\= over the AVL trees themselves. For instance, that lets us detect\n\\= emptiness by comparing to the empty tree, and it lets us detect\n\\= singletonhood by looping over the entries and comparing to the\n\\= singletons of each.\n\\=\n\\= In the process, a lot of ugliness may arise: If concatenation of\n\\= encapsulated AVL trees doesn't somehow check that their\n\\= metacomparators are equivalent, we may end up with malformed\n\\= encapsulated AVL trees that leak implementation details. We could\n\\= potentially avoid this situation by passing some sort of equality\n\\= certifier to the concatenation operation, but then we'd need a\n\\= specialized language (or at least a collection of combinators) for\n\\= defining equality certifiers. An easier approach would be to use a\n\\= specialized language (or combinators) for the metacomparators\n\\= themselves. This language would quickly resemble a static type\n\\= system, much like our \"cmpd\" utilities already resemble algebraic\n\\= data type definitions. So, this probably isn't worth solving until\n\\= we take a typed approach.\n\\=\n\\= For now, we can start small, merely providing a single\n\\= metacomparator over names (`name-metacompare`), rather than aiming\n\\= for efficiency and general computation. As long as we have that, we\n\\= can use inefficient association lists to track free variables\n\\= (`free-vars-object`).\n\n\\= (def-type istring-nil string)\n\\= An interpolated string s-expression that consists of a string with\n\\= no interpolations.\n\n\\= (TODO: Use this.)\n\\= (def-type istring-cons string-past interpolated istring-rest)\n\\= An interpolated string s-expression that consists of a string, a\n\\= single interpolated value to go after that string, and a remaining\n\\= interpolated string s-expression to go after that.\n\n\\= (def-type foreign val)\n\\= An s-expression that consists of an embedded value of any type, but\n\\= usually a name. The program may not know of a way to encode the\n\\= name as serializable data, but it can still be passed to\n\\= `(compile ...)`.\n\n\\= (def-type stx stx-details s-expr)\n\\= An s-expression tagged with source location information.\n\n\\= (defn macro-stx-details mode unique-ns definition-ns stx ...)\n\\= Constructs a syntax details object that refers to a macro's input,\n\\= so that the macro's output can be associated with it. The `stx`\n\\= must be a located cons list whose first element is a string or\n\\= foreign name referring to a macro.\n\n\\= (defn ns-get-name name ns ...)\n\\= Obtains a sub-namespace determined by the given namespace, using\n\\= the given name as a \"folder name.\" Usually, distinct \"folder names\"\n\\= will yield distinct sub-namespaces, but sometimes the interpreter\n\\= may be configured so that this isn't the case.\n\n\\= (defn ns-get-string string ns ...)\n\\= Obtains a sub-namespace determined by the first namespace, using\n\\= the given string as a \"folder name.\" Usually, distinct \"folder\n\\= names\" will yield distinct sub-namespaces, but sometimes the\n\\= interpreter may be configured so that this isn't the case.\n\n\\= (defn ns-shadow-name name sub-ns ns ...)\n\\= Creates a new namespace that behaves like the second namespace in\n\\= almost every way, except when the given name is requested as a\n\\= \"folder name\", in which case the first namespace is returned\n\\= instead.\n\n\\= (defn ns-shadow-string string sub-ns ns ...)\n\\= Creates a new namespace that behaves like the second namespace in\n\\= almost every way, except when the given string is requested as a\n\\= \"folder name\", in which case the first namespace is returned\n\\= instead.\n\n\\= The `ns-shadow-name` and `ns-shadow-string` functions can be used\n\\= to establish local macros. A namespace created this way even works\n\\= the same way as the old one when it's used in a `procure-...`\n\\= primitive. This way, we can imagine that the namespace's own\n\\= identity is stored under an entry somewhere in the namespace, just\n\\= using a key that we don't have the ability to construct.\n\n\\= (defn procure-name mode ns ...)\n\\= Uses the given namespace to obtain a first-class name value. The\n\\= given modality must be the current one.\n\n\\= (defn procure-defined mode ns ...)\n\\= Blocks until the given namespace has a defined Staccato value and\n\\= then returns it. The given modality must be the current one.\n\n\\= (defn procure-put-defined mode ns value then ...)\n\\= then (fn mode ...)\n\\= Constructs a monad that, if invoked, installs a definition so that\n\\= the given namespace has a defined Staccato value, namely the given\n\\= one. The monad's result value is `(nil)`. In a later tick, once the\n\\= definition has been installed, the callback is invoked, and its own\n\\= monadic side effects occur. If the definition cannot be installed,\n\\= the program is in error, and the callback may or may not be\n\\= invoked; other computations that depend on the defined value may or\n\\= may not be canceled or retroactively voided.\n\n\\= (defn no-effects val ...)\n\\= Constructs a monad that, if invoked, does nothing. The monad's\n\\= result value is the given value.\n\n\\= (defn bind-effects monad then ...)\n\\= then (fn result ...)\n\\= Constructs a monad that, if invoked, calls the callback with the\n\\= given monad's result value, obtains a monad as the result of that\n\\= function, and performs the effects of both monads. The monad's\n\\= result value is the result value of the monad returned by the\n\\= callback.\n\n\\= (defn assert-current-modality mode ...)\n\\= Returns `(nil)`. The given modality must be the current one. If it\n\\= isn't, this causes an error.\n\n\\= TODO: See if we want to keep this. It's just here so that we can\n\\= use the naive JavaScript transpiling approach in\n\\= era-staccato-lib-runner-mini.js rather than doing desugaring in\n\\= between.\n\\=\n\\= (defn compile-expression mode unique-ns definition-ns stx ...)\n\\= Macroexpands the given `stx`, allowing the macro calls to\n\\= monadically install definitions and produce a desugarable\n\\= Staccato expression. The given modality must be the current one.\n\n\\= TODO: See if we should add this. Currently we're using monads only\n\\= for collecting outputs from subcomputations, rather than using them\n\\= as a convenience to avoid passing around modalities, namespaces,\n\\= etc. as inputs to subcomputations.\n\\=\n\\= TODO: On the other hand, if we don't add this, all our monadic\n\\= built-ins have `(nil)` as their result value. See if we should\n\\= redesign everything to use an opaque set collection rather than a\n\\= commutative monad.\n\\=\n\\= (defn get-current-modality ...)\n\\=\n\\= Constructs a monad with the current modality as its result value.\n\n\\= (defn new-promise then ...)\n\\= then (fn mode promise ...)\n\\=\n\\= Constructs a monad with a result value of `(nil)`. If invoked, it\n\\= calls the callback in a later tick with the then-current modality\n\\= and a fresh promise value, and it performs the callback's monadic\n\\= side effects. The promise is not yet fulfilled.\n\n\\= (defn promise-fulfillment promise then ...)\n\\= then (fn mode fulfillment ...)\n\\=\n\\= Constructs a monad with a result value of `(nil)`. If invoked, it\n\\= calls the callback in a later tick with the then-current modality\n\\= and the promise's fulfillment value, and it performs the callback's\n\\= monadic side effects. If the promise is never actually fulfilled,\n\\= this callback will not be called.\n\n\\= (defn promise-put-fulfillment promise fulfillment ...)\n\\=\n\\= Constructs a monad with a result value of `(nil)`. If invoked, it\n\\= installs the given value as the fulfillment value of the promise,\n\\= or it causes an error if a fulfillment value has already been\n\\= installed for the promise. (The meaning of \"already\" may depend on\n\\= how the current modality works. For modalities that are temporal in\n\\= the concrete sense of a wall clock, it has its usual meaning.)\n\n\n\n\\= ===== Reimplementation of the desugarer ===========================\n\n\\= Raw Staccato syntax has two places where the values involved are\n\\= not necessarily serializable:\n\\=\n\\= The `(stc-def-foreign ...)` syntax allows the definition to be an\n\\= arbitrary first-class value, so that metacircular interpreters can\n\\= encapsulate their implementation details.\n\\=\n\\= The `(stc-foreign ...)` syntax allows an arbitrary first-class\n\\= value, such as a string, to survive until run time. Most code\n\\= serializers will not support most values.\n\\=\n\\= The `(stc-proj-pattern-omitted ...)` syntax must contain a\n\\= namespace. When the omitted projection names are inferred, they\n\\= will be taken from \"<ns>/<projection name>/name\", where \"<ns>\" is\n\\= that namespace.\n\n\\= TODO: Put the commented-out types in a separate file so the\n\\= non-mini runner can see them, since it doesn't have them built in.\n\\;rm(\n(def-type stc-def-foreign tuple-tag foreign)\n(def-type stc-def tuple-name opt-proj-pattern case-list)\n(def-type stc-let-case var case-list)\n(def-type stc-match tuple-name proj-pattern get-expr case-list)\n(def-type stc-any get-expr)\n(def-type stc-let-bindings-nil)\n(def-type stc-let-bindings-cons var get-expr let-bindings-expr)\n(def-type stc-proj-nil)\n(def-type stc-proj-cons proj-name get-expr proj-expr)\n(def-type stc-let-def def get-expr)\n(def-type stc-let let-bindings-expr get-expr)\n(def-type stc-local var)\n(def-type stc-foreign foreign)\n(def-type stc-do-what-you-think-is-best)\n(def-type stc-tuple tuple-name proj-expr)\n(def-type stc-save-root save-root get-expr)\n(def-type stc-save\n  save-root call-tuple-name\n  call-func tuple-name opt-proj-pattern\n  call-arg var arg)\n(def-type stc-fn tuple-name opt-proj-pattern case-list)\n(def-type stc-proj-pattern-omitted namespace)\n(def-type stc-proj-pattern proj-pattern)\n(def-type stc-proj-pattern-nil)\n(def-type stc-proj-pattern-cons proj-name var proj-pattern)\n)\n\n\n(def-type scope-policy-save-root save-root)\n(def-type scope-policy-not-root)\n(def-type scope-policy-does-not-matter)\n(def-type scope-policy-no-free-vars)\n\n(def-type visitor-object impl)\n(def-type method-visitor-visit part shadow scope-policy)\n(def-type method-visitor-redecorate extra-vars whole)\n(def-type visitor-visit-result result visitor)\n\n(defn make-visitor impl\n  visitor-object.impl)\n\n(defn visitor-visit visitor part shadow scope-policy\n  (cast visitor visitor-object impl\n    err.\\;qq[Expected a visitor of type visitor-object]\n  /c impl /method-visitor-visit part shadow scope-policy))\n\n(defn visitor-redecorate visitor extra-vars whole\n  (cast visitor visitor-object impl\n    err.\\;qq[Expected a visitor of type visitor-object]\n  /c impl /method-visitor-redecorate extra-vars whole))\n\n(defn stringy-name-metacompare a b\n  (bimap (cmpd-compare) a b /fn it\n    (case it string -\n      (cmpd-cons (string-compare) it /cmpd-nil)\n    /cmpd-succ/case it name -\n      (cmpd-cons (name-metacompare) it /cmpd-nil)\n      err.\\;qq[Expected a value of type string or name])))\n\n(def-type free-var-entry-var name)\n(def-type free-var-entry-saved-input-var save-root name)\n(def-type free-var-entry-saved-free-var save-root name)\n(def-type free-var-entry-scope-error message)\n\n(defn free-vars-entry-metacompare a b\n  (bimap (cmpd-compare) a b /fn it\n    (case it free-var-entry-var name\n      (cmpd-cons (stringy-name-metacompare) name /cmpd-nil)\n    /cmpd-succ/case it free-var-entry-saved-input-var save-root name\n      (cmpd-cons (stringy-name-metacompare) save-root\n      /cmpd-cons (stringy-name-metacompare) name\n      /cmpd-nil)\n    /cmpd-succ/case it free-var-entry-saved-free-var save-root name\n      (cmpd-cons (stringy-name-metacompare) save-root\n      /cmpd-cons (stringy-name-metacompare) name\n      /cmpd-nil)\n    /cmpd-succ/case it free-var-entry-scope-error message\n      (cmpd-cons (string-compare) message /cmpd-nil)\n      err.\\;qq[Expected a free variable entry])))\n\n(def-type free-vars-object list)\n\n(defn free-vars-any free-vars check\n  (cast free-vars free-vars-object list\n    err.\\;qq[\n      Called free-vars-any with a free-vars that wasn't a\n      free-vars-object]\n  /any list check))\n\n(defn free-vars-fold state free-vars combiner\n  (cast free-vars free-vars-object list\n    err.\\;qq[\n      Called free-vars-fold with a free-vars that wasn't a\n      free-vars-object]\n  /foldl state list combiner))\n\n(defn free-vars-has free-vars entry\n  (free-vars-any free-vars /fn entry2\n    (isa nil /free-vars-entry-metacompare entry entry2)))\n\n(defn free-vars-keep free-vars check\n  (cast free-vars free-vars-object list\n    err.\\;qq[\n      Called free-vars-keep with a free-vars that wasn't a\n      free-vars-object]\n  /free-vars-object /keep list check))\n\n(defn free-vars-minus a b\n  (free-vars-keep a /fn entry /not/free-vars-has b entry))\n\n(defn free-vars-plus-entry free-vars entry\n  (cast free-vars free-vars-object list\n    err.\\;qq[\n      Called free-vars-plus-entry with a free-vars that wasn't a\n      free-vars-object]\n  /case (free-vars-has free-vars entry)\n    yep - free-vars\n    (free-vars-object /cons entry list)))\n\n(defn free-vars -\n  (free-vars-object/nil))\n\n(defn free-vars-just entry\n  (free-vars-plus-entry (free-vars/nil) entry))\n\n(defn free-vars-map free-vars func\n  (free-vars-fold (free-vars/nil) free-vars /fn state entry\n    (free-vars-plus-entry state /c func entry)))\n\n(defn free-vars-plus a b\n  (free-vars-fold a b /fn state entry\n    (free-vars-plus-entry state entry)))\n\n\n(defn staccato-let-bindings-expr-keys let-bindings-expr\n  (case let-bindings-expr\n    \n    stc-let-bindings-nil\n    (free-vars/nil)\n    \n    stc-let-bindings-cons var get-expr let-bindings-expr\n    (free-vars-plus-entry\n      (c-new staccato-let-bindings-expr-keys let-bindings-expr)\n      free-var-entry-var.var)\n    \n    err.\\;qq[\n      Called staccato-let-bindings-expr-keys on a value that wasn't a\n      let-bindings-expr syntax]))\n\n(defn staccato-proj-pattern-get-vars proj-pattern\n  (case proj-pattern\n    \n    stc-proj-pattern-nil\n    (free-vars/nil)\n    \n    stc-proj-pattern-cons proj-name var proj-pattern\n    (free-vars-plus-entry\n      (c-new staccato-proj-pattern-get-vars proj-pattern)\n      free-var-entry-var.var)\n    \n    err.\\;qq[\n      Called staccato-proj-pattern-get-vars on a value that wasn't a\n      proj-pattern syntax]))\n\n(defn staccato-opt-proj-pattern-get-vars opt-proj-pattern\n  (case opt-proj-pattern\n    \n    stc-proj-pattern-omitted namespace\n    (nil)\n    \n    stc-proj-pattern proj-pattern\n    (yep staccato-proj-pattern-get-vars.proj-pattern)\n    \n    err.\\;qq[\n      Called staccato-opt-proj-pattern-get-vars on a value that wasn't\n      an opt-proj-pattern syntax]))\n\n(defn opt-proj-pattern-or mode opt-proj-pattern default\n  (let - assert-current-modality.mode\n  /case opt-proj-pattern\n    \n    stc-proj-pattern-omitted namespace\n    (stc-proj-pattern\n    /free-vars-fold (stc-proj-pattern-nil) default /fn state var truth\n      (cast var free-var-entry-var name\n        err.\\;qq[\n          Called opt-proj-pattern-or with a default variable list that\n          contained a key that wasn't a free-var-entry-var]\n      /stc-proj-pattern-cons\n        (procure-name mode\n        /ns-get-string str.name\n        /ns-get-name name namespace)\n        name\n        state))\n    \n    stc-proj-pattern proj-pattern\n    opt-proj-pattern\n    \n    err.\\;qq[\n      Called opt-proj-pattern-or on a value that wasn't an\n      opt-proj-pattern syntax]))\n\n(defn proj-pattern-capture proj-pattern\n  (case proj-pattern\n    \n    stc-proj-pattern-nil\n    (stc-proj-nil)\n    \n    stc-proj-pattern-cons proj-name var proj-pattern\n    (stc-proj-cons proj-name (stc-local var)\n    /c-new proj-pattern-capture proj-pattern)\n    \n    err.\\;qq[\n      Called proj-pattern-capture on a value that wasn't a\n      proj-pattern syntax]))\n\n(defn opt-proj-pattern-capture opt-proj-pattern\n  (case opt-proj-pattern\n    \n    stc-proj-pattern-omitted namespace\n    err.\\;qq[\n      Called opt-proj-pattern-capture on a stc-proj-pattern-omitted]\n    \n    stc-proj-pattern proj-pattern\n    proj-pattern-capture.proj-pattern\n    \n    err.\\;qq[\n      Called opt-proj-pattern-capture on a value that wasn't an\n      opt-proj-pattern syntax]))\n\n\n(defn staccato-visit expr visitor\n  (case expr\n    \n    stc-def-foreign tuple-tag foreign\n    (visitor-redecorate visitor (free-vars/nil)\n    /stc-def-foreign tuple-tag foreign)\n    \n    stc-def tuple-name opt-proj-pattern case-list\n    (cast\n      (visitor-visit visitor case-list\n        (case staccato-opt-proj-pattern-get-vars.opt-proj-pattern\n          yep vars vars\n          (free-vars/nil))\n      /scope-policy-no-free-vars)\n      visitor-visit-result case-list visitor\n      err.\\;qq[Internal error]\n    /visitor-redecorate visitor (free-vars/nil)\n    /stc-def tuple-name opt-proj-pattern case-list)\n    \n    stc-let-case var case-list\n    (cast var string -\n      err.\\;qq[Visited a stc-let-case where the var was not a string]\n    /cast\n      (visitor-visit visitor case-list\n        (free-vars-just free-var-entry-var.var)\n      /scope-policy-does-not-matter)\n      visitor-visit-result case-list visitor\n      err.\\;qq[Internal error]\n    /visitor-redecorate visitor (free-vars/nil)\n    /stc-let-case var case-list)\n    \n    stc-match tuple-name proj-pattern get-expr case-list\n    (cast\n      (visitor-visit visitor get-expr\n        staccato-proj-pattern-get-vars.proj-pattern\n      /scope-policy-not-root)\n      visitor-visit-result get-expr visitor\n      err.\\;qq[Internal error]\n    /cast\n      (visitor-visit visitor case-list (free-vars/nil)\n      /scope-policy-not-root)\n      visitor-visit-result case-list visitor\n      err.\\;qq[Internal error]\n    /visitor-redecorate visitor (free-vars/nil)\n    /stc-match tuple-name proj-pattern get-expr case-list)\n    \n    stc-any get-expr\n    (cast\n      (visitor-visit visitor get-expr (free-vars/nil)\n      /scope-policy-not-root)\n      visitor-visit-result get-expr visitor\n      err.\\;qq[Internal error]\n    /visitor-redecorate visitor (free-vars/nil)\n    /stc-any get-expr)\n    \n    stc-let-bindings-nil\n    (visitor-redecorate visitor (free-vars/nil)\n    /stc-let-bindings-nil)\n    \n    stc-let-bindings-cons var get-expr proj-expr\n    (cast\n      (visitor-visit visitor get-expr (free-vars/nil)\n      /scope-policy-not-root)\n      visitor-visit-result get-expr visitor\n      err.\\;qq[Internal error]\n    /cast\n      (visitor-visit visitor proj-expr (free-vars/nil)\n      /scope-policy-not-root)\n      visitor-visit-result proj-expr visitor\n      err.\\;qq[Internal error]\n    /visitor-redecorate visitor (free-vars/nil)\n    /stc-let-bindings-cons var get-expr proj-expr)\n    \n    stc-proj-nil\n    (visitor-redecorate visitor (free-vars/nil)\n    /stc-proj-nil)\n    \n    stc-proj-cons proj-name get-expr proj-expr\n    (cast\n      (visitor-visit visitor get-expr (free-vars/nil)\n      /scope-policy-not-root)\n      visitor-visit-result get-expr visitor\n      err.\\;qq[Internal error]\n    /cast\n      (visitor-visit visitor proj-expr (free-vars/nil)\n      /scope-policy-not-root)\n      visitor-visit-result proj-expr visitor\n      err.\\;qq[Internal error]\n    /visitor-redecorate visitor (free-vars/nil)\n    /stc-proj-cons proj-name get-expr proj-expr)\n    \n    stc-let-def def get-expr\n    (cast\n      (visitor-visit visitor def (free-vars/nil)\n      /scope-policy-does-not-matter)\n      visitor-visit-result def visitor\n      err.\\;qq[Internal error]\n    /cast\n      (visitor-visit visitor get-expr (free-vars/nil)\n      /scope-policy-not-root)\n      visitor-visit-result get-expr visitor\n      err.\\;qq[Internal error]\n    /visitor-redecorate visitor (free-vars/nil)\n    /stc-let-def def get-expr)\n    \n    stc-let let-bindings-expr get-expr\n    (cast\n      (visitor-visit visitor let-bindings-expr (free-vars/nil)\n      /scope-policy-not-root)\n      visitor-visit-result let-bindings-expr visitor\n      err.\\;qq[Internal error]\n    /cast\n      (visitor-visit visitor get-expr\n        staccato-let-bindings-expr-keys.let-bindings-expr\n      /scope-policy-not-root)\n      visitor-visit-result get-expr visitor\n      err.\\;qq[Internal error]\n    /visitor-redecorate visitor (free-vars/nil)\n    /stc-let let-bindings-expr get-expr)\n    \n    stc-local var\n    (cast var string -\n      err.\\;qq[Visited a stc-local where the var was not a string]\n    /visitor-redecorate visitor\n      (free-vars-just free-var-entry-var.var)\n    /stc-local var)\n    \n    stc-foreign foreign\n    (visitor-redecorate visitor (free-vars/nil)\n    /stc-foreign foreign)\n    \n    stc-do-what-you-think-is-best\n    (visitor-redecorate visitor (free-vars/nil)\n    /stc-do-what-you-think-is-best)\n    \n    stc-tuple tuple-name proj-expr\n    (cast\n      (visitor-visit visitor proj-expr (free-vars/nil)\n      /scope-policy-not-root)\n      visitor-visit-result proj-expr visitor\n      err.\\;qq[Internal error]\n    /visitor-redecorate visitor (free-vars/nil)\n    /stc-tuple tuple-name proj-expr)\n    \n    stc-save-root save-root get-expr\n    (cast save-root string -\n      err.\\;qq[\n        Visited a stc-save-root where the save-root was not a string]\n    /cast\n      (visitor-visit visitor get-expr (free-vars/nil)\n      /scope-policy-save-root save-root)\n      visitor-visit-result get-expr visitor\n      err.\\;qq[Internal error]\n    /visitor-redecorate visitor (free-vars/nil)\n    /stc-save-root save-root get-expr)\n    \n    stc-save\n    save-root call-tuple-name\n    call-func tuple-name opt-proj-pattern\n    call-arg var arg\n    (cast save-root string -\n      err.\\;qq[\n        Visited a stc-save where the save-root was not a string]\n    /cast\n      (visitor-visit visitor arg (free-vars/nil)\n      /scope-policy-save-root save-root)\n      visitor-visit-result arg visitor\n      err.\\;qq[Internal error]\n    /visitor-redecorate visitor\n      (free-vars-plus-entry\n        (case staccato-opt-proj-pattern-get-vars.opt-proj-pattern\n          \n          yep vars\n          (free-vars-map vars /fn entry\n            (cast entry free-var-entry-var name\n              err.\\;qq[Internal error]\n            /free-var-entry-saved-free-var save-root name))\n          \n          (free-vars/nil))\n      /free-var-entry-saved-input-var save-root var)\n    /stc-save\n      save-root call-tuple-name\n      call-func tuple-name opt-proj-pattern\n      call-arg var arg)\n    \n    stc-fn tuple-name opt-proj-pattern case-list\n    (cast\n      (visitor-visit visitor case-list (free-vars/nil)\n      /scope-policy-not-root)\n      visitor-visit-result case-list visitor\n      err.\\;qq[Internal error]\n    /visitor-redecorate visitor\n      (case staccato-opt-proj-pattern-get-vars.opt-proj-pattern\n        yep vars vars\n        (free-vars/nil))\n    /stc-fn tuple-name opt-proj-pattern case-list)\n    \n    err.\\;qq[\n      Called staccato-visit with an expr that wasn't a Staccato\n      expression]))\n\n(defn fix func\n  (fn arg\n    (c func (c-new fix func) arg)))\n\n(defn make-fix-visitor body\n  (make-visitor/fix/fn loop\n    (c body make-visitor.loop)))\n\n(defn id-visitor recur\n  (make-fix-visitor/fn self method /case method\n    \n    method-visitor-visit part shadow scope-policy\n    (visitor-visit-result (c recur part shadow scope-policy) self)\n    \n    method-visitor-redecorate extra-vars whole whole\n    \n    err.\\;qq[Expected method to be a visitor method]))\n\n(def-type desugared-save-expr expr)\n(def-type desugared-save-save\n  desugared-save-root call-tuple-name\n  call-func tuple-name opt-proj-pattern\n  call-arg var arg\n  tuple-body-expr)\n\n(defn staccato-desugar-save expr\n  (case expr\n    \n    stc-save-root save-root get-expr\n    (fix\n      (fn loop expr\n        (caselet desugared (c-new staccato-desugar-save expr)\n          \n          desugared-save-expr expr desugared\n          \n          desugared-save-save\n          desugared-save-root call-tuple-name call-func tuple-name\n          opt-proj-pattern call-arg var arg tuple-body-expr\n          (cast (string-compare save-root desugared-save-root) nil\n            desugared\n          /c loop /stc-save-root save-root\n          /stc-tuple call-tuple-name\n          /stc-proj-cons call-func\n            (stc-fn tuple-name opt-proj-pattern\n              (stc-let-case var\n              /stc-any tuple-body-expr))\n          /stc-proj-cons call-arg arg\n          /stc-proj-nil)\n          \n          err.\\;qq[Internal error]))\n      get-expr)\n    \n    stc-save\n    save-root call-tuple-name\n    call-func tuple-name opt-proj-pattern\n    call-arg var arg\n    (desugared-save-save\n      save-root call-tuple-name\n      call-func tuple-name opt-proj-pattern\n      call-arg var arg\n    /stc-local var)\n    \n    (staccato-visit expr /make-fix-visitor/fn self method /case method\n      \n      method-visitor-visit part shadow scope-policy\n      (case (c-new staccato-desugar-save part)\n        \n        desugared-save-expr expr\n        (visitor-visit-result expr self)\n        \n        desugared-save-save\n        desugared-save-root call-tuple-name call-func tuple-name\n        opt-proj-pattern call-arg var arg tuple-body-expr\n        (visitor-visit-result tuple-body-expr\n        /make-fix-visitor/fn self method /case method\n          \n          method-visitor-visit part shadow scope-policy\n          (visitor-visit-result part self)\n          \n          method-visitor-redecorate extra-vars whole\n          (desugared-save-save\n            desugared-save-root call-tuple-name call-func tuple-name\n            opt-proj-pattern call-arg var arg whole)\n          \n          err.\\;qq[Expected method to be a visitor method])\n        \n        err.\\;qq[Internal error])\n      \n      method-visitor-redecorate extra-vars whole\n      desugared-save-expr.whole\n      \n      err.\\;qq[Expected method to be a visitor method])))\n\n(defn get-free-vars expr\n  (staccato-visit expr /make-visitor/fix\n    (fn visitor-loop result method /case method\n      \n      method-visitor-visit part shadow scope-policy\n      (let shadowed\n        (free-vars-minus (c-new get-free-vars part) shadow)\n      /let shadowed\n        (case\n          (and (isa scope-policy-no-free-vars scope-policy)\n          /free-vars-any shadowed /fn entry\n            (not/isa free-var-entry-scope-error entry))\n          yep -\n          (free-vars-just/free-var-entry-scope-error\n            str.\\;qq[\n              Encountered a use of (def ...) with free variables])\n          shadowed)\n      /let shadowed\n        (case\n          (free-vars-any shadowed /fn entry\n            (case entry free-var-entry-saved-input-var save-root name\n              (free-vars-has shadow free-var-entry-var.name)\n              (nope/nil)))\n          yep -\n          (free-vars-plus-entry shadowed /free-var-entry-scope-error\n            str.\\;qq[\n              Encountered a use of (save ...) where the saved value's\n              variable name was locally bound somewhere between the\n              save root and the saved location])\n          shadowed)\n      /let use-shadowed\n        (fn shadowed\n          (visitor-visit-result part /make-visitor/c visitor-loop\n          /free-vars-plus result shadowed))\n      /let sanitize-and-finish\n        (fn -\n          (case\n            (free-vars-any shadowed /fn entry\n              (or (isa free-var-entry-saved-input-var entry)\n                (isa free-var-entry-saved-free-var entry)))\n            yep -\n            err.\\;qq[\n              Encountered a free variable or a save in an unexpected\n              context]\n          /c use-shadowed shadowed))\n      /case scope-policy\n        \n        scope-policy-save-root save-root\n        (let shadowed\n          (case\n            (free-vars-any shadowed /fn entry\n              (cast entry\n                free-var-entry-saved-input-var save-root-2 name\n                (nope/nil)\n              /and (isa nil /string-compare save-root save-root-2)\n                (free-vars-has shadowed free-var-entry-var.name)))\n            yep -\n            (free-vars-plus-entry shadowed /free-var-entry-scope-error\n              str.\\;qq[\n                Encountered a use of (save ...) where the saved\n                value's variable name was used somewhere under the\n                save root])\n            shadowed)\n        /let shadowed\n          (free-vars-keep shadowed /fn entry\n            (cast entry\n              free-var-entry-saved-input-var save-root-2 name\n              (yep/nil)\n            /not/isa nil /string-compare save-root save-root-2))\n        /let shadowed\n          (free-vars-map shadowed /fn entry\n            (cast entry free-var-entry-saved-free-var save-root-2 name\n              entry\n            /cast (string-compare save-root save-root-2) nil\n              entry\n              free-var-entry-var.name))\n        /c use-shadowed shadowed)\n        \n        scope-policy-not-root (c use-shadowed shadowed)\n        scope-policy-does-not-matter (c sanitize-and-finish /nil)\n        scope-policy-no-free-vars (c sanitize-and-finish /nil)\n        \n        err.\\;qq[Internal error])\n      \n      method-visitor-redecorate extra-vars whole\n      (free-vars-plus result extra-vars)\n      \n      err.\\;qq[Expected method to be a visitor method])\n    (free-vars/nil)))\n\n(defn staccato-desugar-omitted mode expr\n  (let - assert-current-modality.mode\n  /case expr\n    \n    stc-def tuple-name opt-proj-pattern case-list\n    (let inner-free-vars get-free-vars.case-list\n    /stc-def tuple-name\n      (opt-proj-pattern-or mode opt-proj-pattern inner-free-vars)\n      (c-new staccato-desugar-omitted mode case-list))\n    \n    stc-save-root - -2\n    err.\\;qq[Called staccato-desugar-omitted on a stc-save-root]\n    \n    stc-save - -2 -3 -4 -5 -6 -7 -8\n    err.\\;qq[Called staccato-desugar-omitted on a stc-save]\n    \n    stc-fn tuple-name opt-proj-pattern case-list\n    (let inner-free-vars get-free-vars.case-list\n    /stc-fn tuple-name\n      (opt-proj-pattern-or mode opt-proj-pattern inner-free-vars)\n      (c-new staccato-desugar-omitted mode case-list))\n    \n    (staccato-visit expr /id-visitor/fn part shadow scope-policy\n      (c-new staccato-desugar-omitted mode part))))\n\n(defn staccato-desugar-fn expr\n  (case expr\n    \n    stc-save-root - -2\n    err.\\;qq[Called staccato-desugar-fn on a stc-save-root]\n    \n    stc-save - -2 -3 -4 -5 -6 -7 -8\n    err.\\;qq[Called staccato-desugar-fn on a stc-save]\n    \n    stc-fn tuple-name opt-proj-pattern case-list\n    (stc-let-def\n      (stc-def tuple-name opt-proj-pattern\n        (c-new staccato-desugar-fn case-list))\n    /stc-tuple tuple-name opt-proj-pattern-capture.opt-proj-pattern)\n    \n    (staccato-visit expr /id-visitor/fn part shadow scope-policy\n      (c-new staccato-desugar-fn part))))\n\n(def-type desugar-def-result defs expr)\n\n(defn staccato-desugar-def-including-self expr\n  (case expr\n    \n    stc-def-foreign tuple-tag foreign\n    (append defs /cons expr /nil)\n    \n    stc-def tuple-name opt-proj-pattern case-list\n    (cast (c-new staccato-desugar-def case-list)\n      desugar-def-result defs case-list\n      err.\\;qq[Internal error]\n    /append defs\n    /cons (stc-def tuple-name opt-proj-pattern case-list) /nil)\n    \n    err.\\;qq[\n      Called staccato-desugar-def-including-self on an expr that\n      wasn't a stc-def-foreign or a stc-def]))\n\n(defn staccato-desugar-def expr\n  (case expr\n    \n    stc-let-def def get-expr\n    (let desugared-def staccato-desugar-def-including-self.def\n    /cast (c-new staccato-desugar-def get-expr)\n      desugar-def-result defs expr\n      err.\\;qq[Internal error]\n    /desugar-def-result (append desugared-def defs) expr)\n    \n    stc-save-root - -2\n    err.\\;qq[Called staccato-desugar-def on a stc-save-root]\n    \n    stc-save - -2 -3 -4 -5 -6 -7 -8\n    err.\\;qq[Called staccato-desugar-def on a stc-save]\n    \n    stc-fn - -2 -3\n    err.\\;qq[Called staccato-desugar-def on a stc-fn]\n    \n    (staccato-visit expr\n    /make-visitor/fix\n      (fn visitor-loop defs method /case method\n        \n        method-visitor-visit part shadow scope-policy\n        (cast (c-new staccato-desugar-def part)\n          desugar-def-result more-defs expr\n          err.\\;qq[Internal error]\n        /visitor-visit-result expr\n        /make-visitor/c visitor-loop /append defs more-defs)\n        \n        method-visitor-redecorate extra-vars whole\n        (desugar-def-result defs whole)\n        \n        err.\\;qq[Expected method to be a visitor method])\n      (nil))))\n\n\n\n\\= ===== A reimplementation of the macro system ======================\n\n(defn constructor-name mode definition-ns name\n  (let - assert-current-modality.mode\n  /case name\n    name - name\n    \n    string -\n    (procure-name mode\n    /ns-get-string str.name\n    /ns-get-string name\n    /ns-get-string str.constructor-names definition-ns)\n    \n    err.\\;qq[Expected a name value of type name or string]))\n\n(defn projection-name mode definition-ns constructor-name name\n  (let - assert-current-modality.mode\n  /case name\n    name - name\n    \n    string -\n    (procure-name mode\n    /ns-get-string str.name\n    /ns-get-string name\n    /ns-get-string str.projection-names\n    /ns-get-name constructor-name\n    /ns-get-string str.constructors definition-ns)\n    \n    err.\\;qq[Expected a name value of type name or string]))\n\n(defn stx-to-maybe-name stx\n  (cast stx stx - s-expr (nil)\n  /case s-expr\n    foreign foreign-val\n    (cast foreign-val name -\n      err.\\;qq[Expected a foreign-val value of type name]\n      yep.foreign-val)\n    \n    istring-nil string\n    (cast string string -\n      err.\\;qq[Expected a string value of type string]\n      yep.string)\n    \n    (nil)))\n\n(def-type proj-entry name val)\n\n(defn compile-proj-pattern proj-entries\n  (foldr proj-entries (stc-proj-pattern-nil) /fn proj-entry state\n    (cast proj-entry proj-entry name var\n      err.\\;qq[Expected a proj-entry value of type proj-entry]\n    /stc-proj-pattern-cons name var state)))\n\n(defn compile-tuple mode definition-ns constructor-name proj-entries\n  (let constructor-name\n    (constructor-name mode definition-ns constructor-name)\n  /let constructor-tag\n    (procure-name mode\n    /ns-get-string str.tag\n    /ns-get-name constructor-name\n    /ns-get-string str.constructors definition-ns)\n  /stc-tuple constructor-tag\n  /foldr proj-entries (stc-proj-nil) /fn proj-entry state\n    (cast proj-entry proj-entry name val\n      err.\\;qq[Expected a proj-entry value of type proj-entry]\n    /stc-proj-cons\n      (projection-name mode definition-ns constructor-name name)\n      val\n      state)))\n\n(defn compile-ret mode definition-ns val\n  (compile-tuple mode definition-ns str.return\n  /cons (proj-entry str.val val) /nil))\n\n(defn compile-ret-tuple\n  mode definition-ns constructor-name proj-entries\n  \n  (compile-ret mode definition-ns\n  /compile-tuple mode definition-ns constructor-name proj-entries))\n\n(defn no-projs definition-ns constructor-name\n  (stc-proj-pattern-omitted\n  /ns-get-string str.projection-names\n  /ns-get-name constructor-name\n  /ns-get-string str.constructors definition-ns))\n\n(defn compile-save mode unique-ns definition-ns val\n  (let func-name (procure-name mode /ns-get-string str.func unique-ns)\n  /let call-name (constructor-name mode definition-ns str.call)\n  /let call-tag\n    (procure-name mode\n    /ns-get-string str.tag\n    /ns-get-name call-name\n    /ns-get-string str.constructors definition-ns)\n  /let func-proj-name\n    (projection-name mode definition-ns call-name str.func)\n  /let arg-proj-name\n    (projection-name mode definition-ns call-name str.arg)\n  /stc-save str.sr call-tag\n    func-proj-name func-name (no-projs definition-ns func-name)\n    arg-proj-name (procure-name mode /ns-get-string str.arg unique-ns)\n    val))\n\n(defn compile-save-root val\n  (stc-save-root str.sr val))\n\n(defn compile mode unique-ns definition-ns stx\n  \\= Macroexpands the given `stx`, allowing the macro calls to\n  \\= monadically install definitions and produce a desugarable\n  \\= Staccato expression. The given modality must be the current one.\n  \n  (cast stx stx - s-expr\n    err.\\;qq[Expected a stx value of type stx]\n  /case stx-to-maybe-name.stx yep name\n    (compile-ret mode definition-ns stc-local.name)\n  /cast s-expr cons first-stx rest-stxs\n    err.\\;qq[\n      Expected an s-expr value of type foreign, istring-nil, or cons]\n  /cast stx-to-maybe-name.first-stx yep name\n    err.\\;qq[Expected a first-stx value that was a syntactic name]\n  /let name\n    (case name\n      name - name\n      \n      string -\n      (procure-name mode\n      /ns-get-string str.name\n      /ns-get-string name\n      /ns-get-string str.macro-names definition-ns)\n      \n      err.\\;qq[Internal error])\n  /let macro\n    (procure-defined mode\n    /ns-get-string str.function\n    /ns-get-name name\n    /ns-get-string str.macros definition-ns)\n  /c macro mode unique-ns definition-ns\n    (macro-stx-details mode unique-ns definition-ns stx)\n    rest-stxs))\n\n\n\n\\= ===== Metacircular macro system ===================================\n\n\\= Yes, we're using deterministic, referentially transparent side\n\\= effects during macroexpansion. Since a macro will necessarily need\n\\= to *read* existing definitions in order for its implementation code\n\\= to do anything at all, we're allowing other blocking reads by way\n\\= of `procure-defined`. For referential transparency, the\n\\= corresponding `procure-put-defined` writes are performed in a\n\\= commutative monad. If two or more conflicting writes are performed,\n\\= all definitions that depended on reading those writes will be\n\\= retroactively updated. Usually, conflicting definitions are an\n\\= error. However, at a REPL, definitions from a newer command may\n\\= take the place of definitions from an older command without error.\n\\= Errors or updates may cascade through several layers of other\n\\= definitions that depended on them.\n\\=\n\\= Common definitions are stored like so, where slashes represent\n\\= `ns-get-string` except where marked as `ns-get-name`:\n\\=\n\\=   <definition-ns>/constructor-names/<constructor name string>/name\n\\=     = No defined value, but the proper identity to use for the\n\\=       constructor in generated code.\n\\=\n\\=   <definition-ns>/constructors/<ns-get-name: constructor identity>/\n\\=     tag\n\\=     = No defined value, but the identity to use for the constructor\n\\=       in raw Staccato code.\n\\=   <definition-ns>/constructors/<ns-get-name: constructor identity>/\n\\=     projection-list\n\\=     = An ordered list of projection name strings. Projections\n\\=       should only be treated as an ordered list in manually\n\\=       keyboarded code and in macros catering to manually keyboarded\n\\=       code.\n\\=   <definition-ns>/constructors/<ns-get-name: constructor identity>/\n\\=     projection-names/<projection name string>/name\n\\=     = No defined value, but the proper identity to use for the\n\\=       projection in everything except manually keyboarded code.\n\\=\n\\=   <definition-ns>/macro-names/<macro name string>/name\n\\=     = No defined value, but the proper identity to use for the\n\\=       macro in everything except manually keyboarded code.\n\\=\n\\=   <definition-ns>/macros/<ns-get-name: macro identity>/function\n\\=     = A value that can be invoked with the arguments of a macro\n\\=       call.\n\\=\n\\=   <definition-ns>/functions/<ns-get-name: `make-tuple-tag` result>/\n\\=     staccato\n\\=     = An s-expression that can be compiled as a raw, sugarless\n\\=       Staccato function definition.\n\\=\n\\= The usual definition forms generate several definitions all at\n\\= once:\n\\=\n\\=   (def-type ...)\n\\=     * The constructor name information desired.\n\\=     * A macro so that the construction is easy to do.\n\\=     * The name information for that macro.\n\\=     * Constructor name information for a callable value which\n\\=       implements that macro.\n\\=     * A function implementation for that callable value.\n\\=\n\\=   (defn ...)\n\\=     * The function implementation desired.\n\\=     * Constructor name information for a first-class representation\n\\=       of the function.\n\\=     * A macro so that the function is easy to call. (Fortunately,\n\\=       every (defn ...) macro can reuse the same callable value\n\\=       constructor and function implementation.)\n\\=     * The name information for that macro.\n\\=\n\\= A macro's `mode` parameter is the current modality. A modality must\n\\= be passed to certain effectful primitives as a way to give the\n\\= effects something to be deterministic by. (The terms \"mode\" and\n\\= \"modality\" might be idiosyncrasies of this codebase. A more\n\\= standard term is \"world-passing style.\")\n\\=\n\\= A macro's `unique-ns` parameter is a namespace. It's useful in the\n\\= way that gensyms are typically useful in other macro-capable\n\\= languages, but the uniqueness is achieved by playing along: If the\n\\= macro compiles more than one subexpression, each subexpression\n\\= should be given a `unique-ns` derived in different ways from this\n\\= one.\n\\=\n\\= A macro's `definition-ns` parameter is a namespace. If the macro\n\\= needs to install any definitions or look up any definitions, this\n\\= is the namespace for that purpose. It should usually be passed\n\\= as-is to any compiled subexpressions, except when defining a macro\n\\= that's local to a certain subexpression.\n\\=\n\\= A macro's `my-stx-details` parameter is a collection of source\n\\= location information. There's no direct way to deconstruct this\n\\= value, but it conveys information about this macro invocation, so\n\\= the macro can use it to receive attribution for any `stx` values it\n\\= creates.\n\\=\n\\= (TODO: Figure out what the format of source location information\n\\= actually is. For now, this is sort of just an unspecified area, but\n\\= at least a language implementation can use this to hold filenames\n\\= and line numbers in practice. An implementation should be able to\n\\= treat this as a completely empty data structure; it's not needed\n\\= for any variable scoping purposes.)\n\\=\n\\= A macro's `args` parameter is a list of `(stx stx-details s-expr)`\n\\= values. The list is built out of `(cons car cdr)` and `(nil)`\n\\= values.\n\n(defn macro-name mode definition-ns name\n  (let - assert-current-modality.mode\n  /case name\n    name - name\n    \n    string -\n    (procure-name mode\n    /ns-get-string str.name\n    /ns-get-string name\n    /ns-get-string str.macro-names definition-ns)\n    \n    err.\\;qq[Expected a name value of type name or string]))\n\n(defn core-mac-case mode unique-ns definition-ns my-stx-details args\n  (let s (fn it /stx my-stx-details it)\n  /let mac\n    (fn str rest\n      (cons (c s /foreign/macro-name mode definition-ns str) rest))\n  /compile mode (ns-get-string str.body unique-ns) definition-ns\n  /c s /c mac str.caselet\n  /cons (c s /foreign/ns-get-string str.ignored unique-ns)\n    args))\n\n(defn core-mac-cast mode unique-ns definition-ns my-stx-details args\n  (let s (fn it /stx my-stx-details it)\n  /let mac\n    (fn str rest\n      (cons (c s /foreign/macro-name mode definition-ns str) rest))\n  /cast args cons subject args\n    err.\\;qq[Not enough arguments to cast]\n  /cast args cons constructor-name args\n    err.\\;qq[Not enough arguments to cast]\n  /cast stx-to-maybe-name.constructor-name yep constructor-name\n    err.\\;qq[\n      Expected a constructor-name value that was a syntactic name]\n  /let constructor-name\n    (constructor-name mode definition-ns constructor-name)\n  /let projection-list\n    (procure-defined mode\n    /ns-get-string str.projection-list\n    /ns-get-name constructor-name\n    /ns-get-string str.constructors definition-ns)\n  /cast (maybe-cut projection-list args) yep cut-result\n    err.\\;qq[Not enough arguments to cast to the given constructor]\n  /cast cut-result cut-result vars args\n    err.\\;qq[Internal error]\n  /cast args cons else args\n    err.\\;qq[Not enough arguments to cast to the given constructor]\n  /cast args cons then args\n    err.\\;qq[Not enough arguments to cast to the given constructor]\n  /cast args nil\n    err.\\;qq[Too many arguments to cast to the given constructor]\n  /compile mode unique-ns definition-ns\n  /c s /c mac str.case /cons subject\n  /cons (c s /foreign constructor-name)\n  /append (map vars /fn var /c s /foreign var)\n  /cons then\n  /cons else /nil))\n\n(defn compile-call mode definition-ns func arg\n  (compile-tuple mode definition-ns str.call\n  /cons (proj-entry str.func func)\n  /cons (proj-entry str.arg arg)\n  /nil))\n\n(defn map-double list-a list-b func\n  (cast list-a cons first-a rest-a (nil)\n  /cast list-b cons first-b rest-b (nil)\n  /cons (c func first-a first-b)\n    (c-new map-double rest-a rest-b func)))\n\n(defn core-mac-caselet\n  mode unique-ns definition-ns my-stx-details args\n  \n  (let s (fn it /stx my-stx-details it)\n  /let mac\n    (fn str rest\n      (cons (c s /foreign/macro-name mode definition-ns str) rest))\n  /cast args cons var args\n    err.\\;qq[Not enough arguments to caselet]\n  /cast stx-to-maybe-name.var yep var\n    err.\\;qq[Expected a var value that was a syntactic name]\n  /cast args cons subject args\n    err.\\;qq[Not enough arguments to caselet]\n  /let process-tail\n    (fix/fn process-tail unique-ns args\n      (cast args cons first args\n        err.\\;qq[Not enough arguments to caselet]\n      /case args nil\n        (bind-effects (compile mode unique-ns definition-ns first)\n        /fn first\n        /no-effects/stc-any/compile-save-root first)\n      /let constructor-name first\n      /cast stx-to-maybe-name.constructor-name yep constructor-name\n        err.\\;qq[\n          Expected a constructor-name value that was a syntactic name]\n      /let constructor-name\n        (constructor-name mode definition-ns constructor-name)\n      /let constructor-tag\n        (procure-name mode\n        /ns-get-string str.tag\n        /ns-get-name constructor-name\n        /ns-get-string str.constructors definition-ns)\n      /let projection-list\n        (procure-defined mode\n        /ns-get-string str.projection-list\n        /ns-get-name constructor-name\n        /ns-get-string str.constructors definition-ns)\n      /cast (maybe-cut projection-list args) yep cut-result\n        err.\\;qq[Not enough arguments to match the given constructor]\n      /cast cut-result cut-result vars args\n        err.\\;qq[Internal error]\n      /cast args cons then args\n        err.\\;qq[Not enough arguments to match the given constructor]\n      /bind-effects\n        (compile mode (ns-get-string str.first unique-ns)\n          definition-ns then)\n      /fn then\n      /bind-effects\n        (c process-tail (ns-get-string str.rest unique-ns) args)\n      /fn else\n      /no-effects/stc-match constructor-tag\n        (compile-proj-pattern\n        /map-double projection-list vars /fn name var\n          (cast stx-to-maybe-name.var yep var\n            err.\\;qq[Expected a var value that was a syntactic name]\n          /proj-entry name var))\n        compile-save-root.then\n        else))\n  /bind-effects\n    (compile mode (ns-get-string str.subject unique-ns) definition-ns\n      subject)\n  /fn subject\n  /bind-effects\n    (c process-tail (ns-get-string str.body unique-ns) args)\n  /fn body\n  /no-effects/let function-name (ns-get-string str.func unique-ns)\n  /compile-call mode definition-ns\n    (stc-fn function-name (no-projs definition-ns function-name)\n      (stc-let-case var body))\n    compile-save-root.subject))\n\n(defn core-mac-isa mode unique-ns definition-ns my-stx-details args\n  (let s (fn it /stx my-stx-details it)\n  /let mac\n    (fn str rest\n      (cons (c s /foreign/macro-name mode definition-ns str) rest))\n  /cast args cons constructor-name args\n    err.\\;qq[Not enough arguments to isa]\n  /cast args cons val args\n    err.\\;qq[Not enough arguments to isa]\n  /cast args nil\n    err.\\;qq[Too many arguments to isa]\n  /cast stx-to-maybe-name.constructor-name yep constructor-name\n    err.\\;qq[\n      Expected a constructor-name value that was a syntactic name]\n  /let constructor-name\n    (constructor-name mode definition-ns constructor-name)\n  /let projection-list\n    (procure-defined mode\n    /ns-get-string str.projection-list\n    /ns-get-name constructor-name\n    /ns-get-string str.constructors definition-ns)\n  /compile mode (ns-get-string str.body unique-ns) definition-ns\n  /c s /c mac str.case /cons subject\n  /cons (c s /foreign constructor-name)\n  /append\n    (map projection-list /fn projection-name\n      (c s /foreign\n      /procure-name mode\n      /ns-get-name projection-name\n      /ns-get-string str.ignored unique-ns))\n  \\= NOTE: We could reimplement this without depending on `yep`,\n  \\= `nope`, and `nil` macros here, but we're treating those macros as\n  \\= built-ins.\n  /cons (c mac str.yep /cons (c mac str.nil /nil) /nil)\n  /cons (c mac str.nope /cons (c mac str.nil /nil) /nil) /nil))\n\n(defn core-mac-proj1 mode unique-ns definition-ns my-stx-details args\n  (let s (fn it /stx my-stx-details it)\n  /let mac\n    (fn str rest\n      (cons (c s /foreign/macro-name mode definition-ns str) rest))\n  /cast args cons constructor-name args\n    err.\\;qq[Not enough arguments to proj1]\n  /cast args cons val args\n    err.\\;qq[Not enough arguments to proj1]\n  /cast args nil\n    err.\\;qq[Too many arguments to proj1]\n  /compile mode unique-ns definition-ns\n  /c s /c mac str.case /cons val\n  /cons constructor-name /cons (c s /istring-nil str.val)\n  /cons (c s /istring-nil str.val)\n  /cons\n    (c mac str.err\n    /cons (c s /istring-nil str.\\;qq[Internal error]) /nil)\n  /nil))\n\n(defn foldl-effects state rest combiner\n  (case rest cons first rest\n    (bind-effects (c combiner state first) /fn state\n    /c-new foldl-effects state rest combiner)\n    no-effects.state))\n\n(defn each-effects rest body\n  (bind-effects\n    (foldl-effects (nil) rest /fn state elem\n      (bind-effects (c body elem)\n      /no-effects/nil))\n  /no-effects/nil))\n\n(defn compile-curried-calls mode unique-ns definition-ns func args\n  (let - assert-current-modality.mode\n  /bind-effects\n    (foldl-effects (pair func unique-ns) args /fn state arg\n      (cast state pair func unique-ns\n        err.\\;qq[Internal error]\n      /bind-effects\n        (compile mode (ns-get-string str.arg unique-ns) definition-ns\n          arg)\n      /fn arg\n      /no-effects/pair\n        (compile-call mode definition-ns\n          (compile-save mode (ns-get-string str.func unique-ns)\n            definition-ns func)\n          arg)\n        (ns-get-string str.rest unique-ns)))\n  /fn state\n  /no-effects/cast state pair func unique-ns\n    err.\\;qq[Internal error]\n    func))\n\n(defn core-mac-c mode unique-ns definition-ns my-stx-details args\n  (cast args cons func args\n    err.\\;qq[Not enough arguments to c]\n  /bind-effects\n    (compile mode (ns-get-string str.first unique-ns) definition-ns\n      func)\n  /fn func\n  /compile-curried-calls mode (ns-get-string str.rest unique-ns)\n    definition-ns func args))\n\n(defn core-mac-c-new mode unique-ns definition-ns my-stx-details args\n  (cast args cons constructor-name args\n    err.\\;qq[Not enough arguments to c-new]\n  /cast stx-to-maybe-name.constructor-name yep constructor-name\n    err.\\;qq[\n      Expected a constructor-name value that was a syntactic name]\n  /let constructor-name\n    (constructor-name mode definition-ns constructor-name)\n  /let constructor-tag\n    (procure-name mode\n    /ns-get-string str.tag\n    /ns-get-name constructor-name\n    /ns-get-string str.constructors definition-ns)\n  /compile-curried-calls mode unique-ns definition-ns\n    (stc-tuple constructor-tag /stc-proj-nil)\n    args))\n\n(defn map-foldl-effects state rest combiner\n  (case rest cons first rest\n    (bind-effects (c combiner state first) /fn combiner-result\n    /cast combiner-result folding state elem\n      err.\\;qq[Expected combiner-result to be a value of type folding]\n    /cast (c-new map-foldl-effects state rest combiner)\n      folding state list\n      err.\\;qq[Internal error]\n    /folding state /cons elem list)\n    (folding state /nil)))\n\n(defn constructor-macro\n  constructor-name proj-names mode unique-ns definition-ns\n  my-stx-details args\n  \n  (cast (maybe-cut proj-names args) yep cut-result\n    err.\\;qq[Not enough arguments to a constructor]\n  /cast cut-result cut-result proj-vals args\n    err.\\;qq[Internal error]\n  /bind-effects\n    (map-foldl-effects unique-ns proj-vals /fn unique-ns proj-val\n      (bind-effects\n        (compile mode (ns-get-string str.first unique-ns)\n          definition-ns proj-val)\n      /fn proj-val\n      /folding (ns-get-string str.rest unique-ns)\n      /compile-save mode (ns-get-string str.save unique-ns)\n        definition-ns proj-val))\n  /fn folding-proj-vals\n  /cast folding-proj-vals folding unique-ns proj-vals\n    err.\\;qq[Internal error]\n  /compile-curried-calls mode unique-ns definition-ns\n    (compile-ret-tuple mode definition-ns constructor-name\n    /map-double proj-names proj-vals /fn name val\n      (proj-entry\n        (projection-name mode definition-ns\n          (constructor-name mode definition-ns constructor-name)\n          name)\n        val))\n    args))\n\n(defn compile-def-type mode definition-ns name projection-list\n  (let constructor-name (constructor-name mode definition-ns name)\n  /bind-effects\n    (procure-put-defined\n      (ns-get-string str.projection-list\n      /ns-get-name constructor-name\n      /ns-get-name str.constructors definition-ns)\n    /map projection-list /fn projection-name\n      (projection-name\n        mode definition-ns constructor-name projection-name))\n  /fn -\n  /bind-effects\n    (procure-put-defined\n      (ns-get-string str.function\n      /ns-get-name (macro-name mode definition-ns name)\n      /ns-get-name str.macros definition-ns)\n    /constructor-macro name projection-list)\n  /fn -\n  /no-effects/compile-ret-tuple mode definition-ns str.nil /nil))\n\n(defn core-mac-def-type\n  mode unique-ns definition-ns my-stx-details args\n  \n  (let s (fn it /stx my-stx-details it)\n  /let mac\n    (fn str rest\n      (cons (c s /foreign/macro-name mode definition-ns str) rest))\n  /cast args cons name args\n    err.\\;qq[Not enough arguments to def-type]\n  /cast stx-to-maybe-name.name yep name\n    err.\\;qq[Expected a name value that was a syntactic name]\n  /let projection-list\n    (map args /fn proj-name\n      (cast stx-to-maybe-name.proj-name yep proj-name\n        err.\\;qq[Expected a proj-name value that was a syntactic name]\n        proj-name))\n  /compile-def-type mode definition-ns name projection-list))\n\n\\= NOTE: This metacircular implementation of the `(defn ...)` macro\n\\= runs the desugarer defined in this file\n\\= (`staccato-desugar-def-including-self`) so that the next-outer\n\\= metacircular interpreter doesn't have to.\n(defn core-mac-defn mode unique-ns definition-ns my-stx-details args\n  (let s (fn it /stx my-stx-details it)\n  /let mac\n    (fn str rest\n      (cons (c s /foreign/macro-name mode definition-ns str) rest))\n  /cast args cons function-name args\n    err.\\;qq[Not enough arguments to defn]\n  /cast stx-to-maybe-name.function-name yep function-name\n    err.\\;qq[Expected a function-name value that was a syntactic name]\n  /let constructor-name\n    (constructor-name mode definition-ns function-name)\n  /let constructor-tag\n    (procure-name mode\n    /ns-get-string str.tag\n    /ns-get-name constructor-name\n    /ns-get-string str.constructors definition-ns)\n  /cast args cons first-param args\n    err.\\;qq[Not enough arguments to defn]\n  /cast stx-to-maybe-name.first-param yep first-param\n    err.\\;qq[Expected a first-param value that was a syntactic name]\n  /bind-effects\n    (compile mode unique-ns definition-ns /c s /c mac str.fn args)\n  /fn body\n  /bind-effects\n    (each-effects\n      (staccato-desugar-def-including-self\n      /staccato-desugar-fn\n      /staccato-desugar-omitted mode\n      /staccato-desugar-save\n      /stc-def constructor-tag (stc-proj-pattern-nil)\n      /stc-let-case first-param\n      /stc-any/compile-save-root body)\n    /fn def\n      (let tuple-tag\n        (case def\n          \n          stc-def-foreign tuple-tag foreign tuple-tag\n          \n          stc-def tuple-name opt-proj-pattern case-list\n          (cast opt-proj-pattern stc-proj-pattern proj-pattern\n            err.\\;qq[Expected a def value that was already desugared]\n          /make-tuple-tag tuple-name\n            (free-vars-fold (nil)\n              staccato-proj-pattern-get-vars.proj-pattern\n            /fn state var\n              (cons var state)))\n          \n          err.\\;qq[\n            Expected a def value of type stc-def-foreign or stc-def])\n      /procure-put-defined mode\n        (ns-get-string str.staccato\n        /ns-get-name tuple-tag\n        /ns-get-name str.functions definition-ns)\n        def\n        (fn mode /nil)))\n  /fn -\n  /compile-def-type mode definition-ns function-name /nil))\n\n(defn core-mac-fn mode unique-ns definition-ns my-stx-details args\n  (cast rev.args cons body rev-params\n    err.\\;qq[Not enough arguments to fn]\n  /bind-effects\n    (foldl-effects\n      (pair (ns-get-string str.params unique-ns)\n      /compile-save-root/compile mode\n        (ns-get-string str.body-body unique-ns)\n        definition-ns body)\n      rev-params\n    /fn state param\n      (cast state pair unique-ns result\n        err.\\;qq[Internal error]\n      /cast stx-to-maybe-name.param yep param\n        err.\\;qq[Expected a param value that was a syntactic name]\n      /let func-name\n        (procure-name mode /ns-get-string str.func unique-ns)\n      /pair (ns-get-string str.rest unique-ns)\n      /compile-ret mode definition-ns\n      /stc-fn func-name (no-projs definition-ns func-name)\n      /stc-let-case param\n      /stc-any result))\n  /fn state\n  /cast state pair unique-ns result\n    err.\\;qq[Internal error]\n  /no-effects result))\n\n(defn core-mac-let mode unique-ns definition-ns my-stx-details args\n  (cast args cons var args\n    err.\\;qq[Not enough arguments to let]\n  /cast stx-to-maybe-name.var yep var\n    err.\\;qq[Expected a var value that was a syntactic name]\n  /cast args cons val args\n    err.\\;qq[Not enough arguments to let]\n  /cast args cons body args\n    err.\\;qq[Not enough arguments to let]\n  /cast args nil\n    err.\\;qq[Too many arguments to let]\n  /bind-effects\n    (compile mode (ns-get-string str.val-body unique-ns) definition-ns\n      val)\n  /fn val\n  /bind-effects\n    (compile mode (ns-get-string str.body unique-ns) definition-ns\n      body)\n  /fn body\n  /no-effects/stc-let\n    (stc-let-bindings-cons var\n      (compile-save mode (ns-get-string str.val-save unique-ns)\n        definition-ns val)\n    /stc-let-bindings-nil)\n    body))\n\n(defn core-mac-str mode unique-ns definition-ns my-stx-details args\n  (let - assert-current-modality.mode\n  /cast args cons string args\n    err.\\;qq[Not enough arguments to str]\n  /cast string istring-nil string\n    err.\\;qq[Expected a string value of type istring-nil]\n  /cast string string -\n    err.\\;qq[Expected a string value of type string]\n  /cast args nil\n    err.\\;qq[Too many arguments to str]\n  /no-effects/stc-foreign string))\n\n(defn core-mac-err mode unique-ns definition-ns my-stx-details args\n  (cast args cons string args\n    err.\\;qq[Not enough arguments to err]\n  /cast string istring-nil string\n    err.\\;qq[Expected a string value of type istring-nil]\n  /cast string string -\n    err.\\;qq[Expected a string value of type string]\n  /cast args nil\n    err.\\;qq[Too many arguments to err]\n  /no-effects/compile-call mode definition-ns\n    (stc-do-what-you-think-is-best)\n    stc-foreign.string))\n\n(def-type type-declaration name projection-list)\n(def-type foreign-declaration name foreign)\n\n(defn init-definition-ns\n  mode metacircular-definition-ns target-definition-ns\n  \n  \\= TODO: Throughout the code, remove (or at least comment out) the\n  \\= `def-type` declaration of each type that's inherited this way,\n  \\= since it's supposedly already been inherited.\n  (let type\n    (fn name projection-list rest\n      (cons (type-declaration name projection-list) rest))\n  /let inherited-types\n    \\= These constructors are needed so that macros can generate\n    \\= raw Staccato code.\n    \\= TODO: See if we should keep the ones marked \"sugar\".\n    (c type str.return (cons str.val /nil)\n    /c type str.call (cons str.func /cons str.arg /nil)\n    /c type str.stc-def-foreign\n      (cons str.tuple-tag /cons str.foreign /nil)\n    /c type str.stc-def\n      (cons str.tuple-name /cons str.opt-proj-pattern\n      /cons str.case-list /nil)\n    /c type str.stc-let-case (cons str.var /cons str.case-list /nil)\n    /c type str.stc-match\n      (cons str.tuple-name /cons str.opt-proj-pattern\n      /cons str.get-expr /cons str.case-list /nil)\n    /c type str.stc-any (cons str.get-expr /nil)\n    /c type str.stc-let-bindings-nil (nil)\n    /c type str.stc-let-bindings-cons\n      (cons str.var /cons str.get-expr\n      /cons str.let-bindings-expr /nil)\n    /c type str.stc-proj-nil (nil)\n    /c type str.stc-proj-cons\n      (cons str.proj-name /cons str.get-expr\n      /cons str.proj-expr /nil)\n    \\= sugar\n    /c type str.stc-let-def (cons str.def /cons str.get-expr /nil)\n    /c type str.stc-let\n      (cons str.let-bindings-expr /cons str.get-expr /nil)\n    /c type str.stc-local (cons str.var /nil)\n    /c type str.stc-foreign (cons str.foreign /nil)\n    /c type str.stc-do-what-you-think-is-best (nil)\n    /c type str.stc-tuple\n      (cons str.tuple-name /cons str.proj-expr /nil)\n    \\= sugar\n    /c type str.stc-save-root\n      (cons str.save-root /cons str.get-expr /nil)\n    \\= sugar\n    /c type str.stc-save\n      (cons str.save-root /cons str.call-tuple-name\n      \n      /cons str.call-func /cons str.tuple-name\n      /cons str.opt-proj-pattern\n      \n      /cons str.call-arg /cons str.var /cons str.arg /nil)\n    \\= sugar\n    /c type str.stc-fn\n      (cons str.tuple-name /cons str.opt-proj-pattern\n      /cons str.case-list /nil)\n    \\= sugar\n    /c type str.stc-proj-pattern-omitted (cons str.namespace /nil)\n    /c type str.stc-proj-pattern (cons str.proj-pattern /nil)\n    /c type str.stc-proj-pattern-nil (nil)\n    /c type str.stc-proj-pattern-cons\n      (cons str.proj-name /cons str.var /cons str.proj-pattern /nil)\n    \n    \\= These constructors are needed for interpreting the results of\n    \\= certain built-in operators, namely `isa` and `string-compare`.\n    /c type str.yep (cons str.val /nil)\n    /c type str.nope (cons str.val /nil)\n    \n    \\= These s-expression constructors are needed so that macros can\n    \\= parse their s-expression arguments. The `cons` and `nil`\n    \\= constructors are also needed for parsing and generating\n    \\= projection lists.\n    /c type str.nil (nil)\n    /c type str.cons (cons str.car /cons str.cdr /nil)\n    /c type str.istring-nil (cons str.string /nil)\n    /c type str.istring-cons\n      (cons str.string-past /cons str.interpolated /cons istring-rest\n      /nil)\n    /c type str.foreign (cons str.val /nil)\n    \n    \\= This constructor is needed so that macros can parse their\n    \\= located syntax arguments.\n    /c type str.stx (cons str.stx-details /cons str.s-expr /nil)\n    \n    \\= These constructors aren't strictly needed, but several built-in\n    \\= operators use these constructors so that it's more convenient\n    \\= for user-level code to detect what type of value it's dealing\n    \\= with.\n    /c type str.string (cons str.val /nil)\n    /c type str.name (cons str.val /nil)\n    \n    /nil)\n  \n  /let shadow-root\n    (fn name ns\n      (ns-shadow-string name\n        (ns-get-string name metacircular-definition-ns)\n        ns))\n  /let target-definition-ns\n    \\= NOTE: We don't shadow `constructor-names` or `macro-names`.\n    \\= That way, the interpreted code can put its definitions in the\n    \\= same place as the metacircular interpreter does, but it can't\n    \\= obtain the names that the interpreter wants to be obscure.\n    \\=\n    \\= NOTE: We don't shadow `constructors` or `macros` either. What\n    \\= we use from these, we define from scratch.\n    \\=\n    \\= NOTE: The metacircular interpreter can't define everything in\n    \\= `functions` from scratch. While it could transport every\n    \\= built-in function it knows about, such as `string-compare`,\n    \\= these functions might be implemented as `stc-def-foreign`,\n    \\= delegating to another function whose type this interpreter\n    \\= doesn't know about.\n    \\=\n    (c shadow-root str.functions\n      target-definition-ns)\n  \n  /let ns-get-stringy\n    (fn name ns\n      (case name\n        name - (ns-get-name name ns)\n        string - (ns-get-string name ns)\n        err.\\;qq[Expected a name value of type name or string]))\n  /let ns-shadow-stringy\n    (fn name sub-ns ns\n      (case name\n        name - (ns-shadow-name name sub-ns ns)\n        string - (ns-shadow-string name sub-ns ns)\n        err.\\;qq[Expected a name value of type name or string]))\n  /let ns-shadow-map\n    (fn name source target func\n      (c ns-shadow-stringy name\n        (c func\n          (c ns-get-stringy name source)\n          (c ns-get-stringy name target))\n        target))\n  /let shadow-type\n    (fn name ns\n      (let source metacircular-definition-ns\n      /let ns\n        (c ns-shadow-map str.constructor-names source ns /fn source ns\n          (c ns-shadow-map name source ns /fn source ns source))\n      /let ns\n        (c ns-shadow-map str.macro-names source ns /fn source ns\n          (c ns-shadow-map name source ns /fn source ns source))\n        ns))\n  /let target-definition-ns\n    (foldl target-definition-ns inherited-types /fn ns type\n      (cast type type-declaration name proj-list\n        err.\\;qq[Internal error]\n      /c shadow-type name ns))\n  \n  \\= Define all the inherited constructors. Their names are inherited\n  \\= metacircularly, but their projection list metadata and macros are\n  \\= defined from scratch here.\n  /bind-effects\n    (each-effects inherited-types /fn type\n      (cast type type-declaration name proj-list\n        err.\\;qq[Internal error]\n      /compile-def-type mode target-definition-ns name proj-list))\n  /fn -\n  \n  /let def-macro\n    (fn name function next\n      (bind-effects\n        (procure-put-defined mode\n          (procure-name mode\n          /ns-get-string str.function\n          /ns-get-name (macro-name mode target-definition-ns name)\n          /ns-get-string str.macros target-definition-ns)\n          function\n          (fn mode /nil))\n      /fn - next))\n  \\= TODO: Implement this macro, and add it here:\n  \\= def-macro\n  \\= TODO: Also consider adding the `test` macro used in test.stc.\n  /c def-macro str.case (core-mac-case)\n  /c def-macro str.cast (core-mac-cast)\n  /c def-macro str.caselet (core-mac-caselet)\n  /c def-macro str.isa (core-mac-isa)\n  /c def-macro str.proj1 (core-mac-proj1)\n  /c def-macro str.c (core-mac-c)\n  /c def-macro str.c-new (core-mac-c-new)\n  /c def-macro str.def-type (core-mac-def-type)\n  /c def-macro str.defn (core-mac-defn)\n  /c def-macro str.fn (core-mac-fn)\n  /c def-macro str.let (core-mac-let)\n  /c def-macro str.str (core-mac-str)\n  /c def-macro str.err (core-mac-err)\n  \n  \\= NOTE: We've inherited all the built-in function implementations,\n  \\= but we haven't inherited the functions' names, constructors, or\n  \\= macros. Instead of reusing the old names, we obtain the new names\n  \\= and define the constructors and macros from scratch. We define\n  \\= functions under these new names by copying the old\n  \\= implementations (which will usually be `stc-def-foreign` values).\n  /let def-foreign\n    (fn name next\n      (bind-effects\n        (compile-def-type mode target-definition-ns name /nil)\n      /fn -\n      /let constructor-name (constructor-name mode ns name)\n      /let constructor-tag\n        (procure-name mode\n        /ns-get-string str.tag\n        /ns-get-name constructor-name\n        /ns-get-string str.constructors definition-ns)\n      /let get\n        (fn ns\n          (ns-get-string str.staccato\n          /ns-get-name tuple-tag\n          /ns-get-string str.functions ns))\n      /let def\n        (case (procure-defined mode /c get metacircular-definition-ns)\n          \n          stc-def-foreign tuple-tag foreign\n          (stc-def-foreign (make-tuple-tag constructor-tag /nil)\n            foreign)\n          \n          stc-def tuple-name opt-proj-pattern case-list\n          (stc-def constructor-tag opt-proj-pattern case-list)\n          \n          err.\\;qq[\n            Expected a def value of type stc-def-foreign or stc-def])\n      /bind-effects\n        (procure-put-defined mode\n          (procure-name mode /c get target-definition-ns)\n          def\n          (fn mode /nil))\n      /fn - next))\n  /c def-foreign str.string-compare\n  /c def-foreign str.make-tuple-tag\n  /c def-foreign str.name-metacompare\n  /c def-foreign str.macro-stx-details\n  /c def-foreign str.ns-get-name\n  /c def-foreign str.ns-get-string\n  /c def-foreign str.ns-shadow-name\n  /c def-foreign str.ns-shadow-string\n  /c def-foreign str.procure-name\n  /c def-foreign str.procure-defined\n  /c def-foreign str.procure-put-defined\n  /c def-foreign str.no-effects\n  /c def-foreign str.bind-effects\n  /c def-foreign str.assert-current-modality\n  /c def-foreign str.compile-expression\n  \n  /no-effects target-definition-ns))\n\n\n\\= ===== Playing around with macros ==================================\n\n(def-macro list mode unique-ns definition-ns my-stx-details args\n  (let s (fn it /stx my-stx-details it)\n  /let mac\n    (fn str rest\n      (cons (c s /foreign/macro-name mode definition-ns str) rest))\n  /compile-expression mode unique-ns definition-ns\n  /foldr args (c s /c mac str.nil /nil) /fn first rest\n    (c s /c mac str.cons /cons first /cons rest /nil)))\n";
